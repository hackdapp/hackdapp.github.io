<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HackDApp</title>
  
  <subtitle>Focus on DApp tutorials, Thinking growth, Mac skills, IndieMaker, etc.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hackdapp.com/"/>
  <updated>2021-06-28T15:33:38.116Z</updated>
  <id>https://www.hackdapp.com/</id>
  
  <author>
    <name>zhangliang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于以太坊的NFT开发实践</title>
    <link href="https://www.hackdapp.com/archives/how-to-impl-nft-proj.html"/>
    <id>https://www.hackdapp.com/archives/how-to-impl-nft-proj.html</id>
    <published>2021-06-28T15:22:28.000Z</published>
    <updated>2021-06-28T15:33:38.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h2><h3 id="第一部分、项目总览"><a href="#第一部分、项目总览" class="headerlink" title="第一部分、项目总览"></a>第一部分、项目总览</h3><ul><li>项目产品介绍</li><li>代码工程介绍</li><li>技术架构讲解</li><li>基础概念讲解（ERC20、ERC1155、ERC721）</li></ul><h3 id="第二部分、产品架构及功能设计"><a href="#第二部分、产品架构及功能设计" class="headerlink" title="第二部分、产品架构及功能设计"></a>第二部分、产品架构及功能设计</h3><ul><li>产品架构图</li><li>业务流程图</li><li>技术架构图</li></ul><h3 id="第三部分、产品开发及用例测试"><a href="#第三部分、产品开发及用例测试" class="headerlink" title="第三部分、产品开发及用例测试"></a>第三部分、产品开发及用例测试</h3><h4 id="1）智能合约开发"><a href="#1）智能合约开发" class="headerlink" title="1）智能合约开发"></a>1）智能合约开发</h4><ul><li>基础环境配置</li><li>搭建本地链环境</li><li>开发工程构建</li><li>合约设计</li><li>合约测试</li></ul><h4 id="2）IPFS部署与集成"><a href="#2）IPFS部署与集成" class="headerlink" title="2）IPFS部署与集成"></a>2）IPFS部署与集成</h4><h4 id="3）前端页面开发"><a href="#3）前端页面开发" class="headerlink" title="3）前端页面开发"></a>3）前端页面开发</h4><h3 id="第四部分、产品部署"><a href="#第四部分、产品部署" class="headerlink" title="第四部分、产品部署"></a>第四部分、产品部署</h3><ul><li>发布静态工程至github仓库gh-page，并配置公网域名</li><li>发布智能合约至测试网</li></ul><h3 id="第五部分、线上演示及功能验证"><a href="#第五部分、线上演示及功能验证" class="headerlink" title="第五部分、线上演示及功能验证"></a>第五部分、线上演示及功能验证</h3><ul><li>安装MetaMask</li><li>发布NFT</li><li>交易NFT</li><li>转帐NFT</li><li>……</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;课程大纲&quot;&gt;&lt;a href=&quot;#课程大纲&quot; class=&quot;headerlink&quot; title=&quot;课程大纲&quot;&gt;&lt;/a&gt;课程大纲&lt;/h2&gt;&lt;h3 id=&quot;第一部分、项目总览&quot;&gt;&lt;a href=&quot;#第一部分、项目总览&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="以太坊课程" scheme="https://www.hackdapp.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="nft ethereum truffle javascript" scheme="https://www.hackdapp.com/tags/nft-ethereum-truffle-javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何做好课堂笔记</title>
    <link href="https://www.hackdapp.com/archives/how-to-make-goodnotes.html"/>
    <id>https://www.hackdapp.com/archives/how-to-make-goodnotes.html</id>
    <published>2021-06-07T09:24:31.000Z</published>
    <updated>2021-06-07T09:29:04.609Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.hackdapp.com/2021-06-07-%E5%BF%85%E4%BF%AE%E4%BD%9C%E4%B8%9A1-D023-%E5%BC%A0%E4%BA%AE-%E5%8C%97%E4%BA%AC-hackdapp.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://cdn.hackdapp.com/2021-06-07-%E5%BF%85%E4%BF%AE%E4%BD%9C%E4%B8%9A1-D023-%E5%BC%A0%E4%BA%AE-%E5%8C%97%E4%BA%AC-hackdapp.pn
      
    
    </summary>
    
      <category term="知识卡片" scheme="https://www.hackdapp.com/categories/%E7%9F%A5%E8%AF%86%E5%8D%A1%E7%89%87/"/>
    
    
  </entry>
  
  <entry>
    <title>如何提高防猝死的能力</title>
    <link href="https://www.hackdapp.com/archives/20210428-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%98%B2%E7%8C%9D%E6%AD%BB%E7%9A%84%E8%83%BD%E5%8A%9B.html"/>
    <id>https://www.hackdapp.com/archives/20210428-如何提高防猝死的能力.html</id>
    <published>2021-04-28T14:56:16.000Z</published>
    <updated>2021-04-28T15:08:39.509Z</updated>
    
    <content type="html"><![CDATA[<p><strong>猝死就是平时身体健康、或貌似健康的患者，在出乎意料的短时间内，因自然疾病而突然死亡.</strong></p><p><strong>猝死，如此可怕，是哪些原因导致的呢?</strong><br>85%是心血管问题，这其中，又有80%是给心脏供血的冠状动脉突发缺血了。</p><p><strong>那么，猝死我们可以预防或控制吗？</strong><br>好消息是，绝大部分情况可以，前提是你要有足够的心脏储备。而储备，是心血管健康里最容易被忽视的一个维度。所谓心力储备，就是心脏因身体的需要而增加射血的能力。所以，大部分情况下，猝死是由于心力储备坍塌导致的。</p><p><strong>逻辑上有三种策略可以进行预防：</strong></p><ol><li>避免最后一根稻草策略。能引发猝死的事情，我们不要去做。比如： 大量喝酒或咖、心情抑郁、暴饮暴食等等。要注重先兆，要比发现最后一稻草更有效；</li><li>关注身体信号策略。我们要注意引发猝死的先兆，也就是去注意储备透支的信号。</li><li>拓展储备策略。这也是最重要的一种策略。既然储备是一种潜能，那我们就要努力去拓展它</li></ol><p>原文链接: <a href="https://www.dedao.cn/article/w06eGYrQb1gzVxBryXPl73kZRqOaB8" target="_blank" rel="noopener">https://www.dedao.cn/article/w06eGYrQb1gzVxBryXPl73kZRqOaB8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;猝死就是平时身体健康、或貌似健康的患者，在出乎意料的短时间内，因自然疾病而突然死亡.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;猝死，如此可怕，是哪些原因导致的呢?&lt;/strong&gt;&lt;br&gt;85%是心血管问题，这其中，又有80%是给心脏供血的冠状动脉突
      
    
    </summary>
    
      <category term="心脏医学课" scheme="https://www.hackdapp.com/categories/%E5%BF%83%E8%84%8F%E5%8C%BB%E5%AD%A6%E8%AF%BE/"/>
    
    
      <category term="防猝死 得到课程 心脏医学课" scheme="https://www.hackdapp.com/tags/%E9%98%B2%E7%8C%9D%E6%AD%BB-%E5%BE%97%E5%88%B0%E8%AF%BE%E7%A8%8B-%E5%BF%83%E8%84%8F%E5%8C%BB%E5%AD%A6%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何用61分钟写出漂亮的推广文案</title>
    <link href="https://www.hackdapp.com/archives/how_to_write_ad_fast.html"/>
    <id>https://www.hackdapp.com/archives/how_to_write_ad_fast.html</id>
    <published>2021-04-07T10:09:14.000Z</published>
    <updated>2021-04-07T12:28:02.909Z</updated>
    
    <content type="html"><![CDATA[<p>最近，接触了不少通过推荐产品的联盟推广平台，只要你能通过自己的语言或文字，说服别人通过你的链接购买对应商品，那么你就能从中抽取一定的佣金。比如：将京东或淘宝联盟里的产品，通过知乎、蜜源、小红书等平台进行文案宣传。</p><p>在推广过程，你会很快发现，如何能够更好的说报用户，就往往就要考虑一个人的文案能力，当然不仅仅是文字功度，更重要的是你更懂得将适当的产品推送给最需要的人。这其中，就需要你多思考，如何挖掘产品卖点，如何通过数据了解客户需要什么等等。</p><p>对于一些专门写广告文案的高手来讲，往往都有一套自己的写作套路或者方法论，以提高自己的产出效率及效果。最终考验你的不是你写了多少字，而是到底转化多少用户进行付费。</p><p>今天，也是机缘巧合，刷推的时候发现一篇推文觉得写得挺不错的，所以也翻译过来与大家共同学习成长。</p><p>推主的整个写作框架，共拆分成11个小步骤，来实现“花最小的努力产出最好的效果”。</p><h3 id="01-花10分钟-收集广告主资料"><a href="#01-花10分钟-收集广告主资料" class="headerlink" title="01/ 花10分钟, 收集广告主资料"></a>01/ 花10分钟, 收集广告主资料</h3><p>了解你所要推广产品的广告主是谁，经营什么产品，产品解决什么问题，这一切只需要你从对方官网都可以快速了解。除了你从广告主直接获取的信息之外，你还需要通过Google检索与之相竞争的对手与产品是什么。</p><h3 id="02-花5分钟，阅读广告主介绍"><a href="#02-花5分钟，阅读广告主介绍" class="headerlink" title="02/ 花5分钟，阅读广告主介绍"></a>02/ 花5分钟，阅读广告主介绍</h3><p>好好阅读上一步骤所收集到的广告主资料信息。想一想，如果广告主找你聊具体的推广信息，而你对自己的客户一无所知，是不是有点说不过去，所以要提前做好功课。</p><h3 id="03-花5分钟，找到一个卖点"><a href="#03-花5分钟，找到一个卖点" class="headerlink" title="03/ 花5分钟，找到一个卖点"></a>03/ 花5分钟，找到一个卖点</h3><p>你要明白每一个产品往往都会有很多优点或者好处，你不可能使用有限的篇幅来顾及所有信息。所以，你需要依照自己的推广平台的文字限制，来选择性的介绍1个或多个产品卖点。</p><h3 id="04-花1分钟，确定CTA"><a href="#04-花1分钟，确定CTA" class="headerlink" title="04/ 花1分钟，确定CTA"></a>04/ 花1分钟，确定CTA</h3><p>通过添加CTA（Call to action）链接或按钮，可以更容易说服用户采取下一步行动，有利于促进点击率或转化率。CTA要具备三个要素：要推广人们立即行动，而不是晚点再说；应该要求行动，而不是建议行动；引导人们行动的流程要足够简单。</p><p>比如：错误示例，“LearnMore”，“Download”，没有告诉用户所要获得的好处；好的示例，“Get My Free EBook”、“Get 50% Off My Ebook Now”</p><h3 id="05-花10分钟，持续输出文字"><a href="#05-花10分钟，持续输出文字" class="headerlink" title="05/ 花10分钟，持续输出文字"></a>05/ 花10分钟，持续输出文字</h3><p>通过之前对于广告主及产品的了解、选定的推广卖点以及CTA等多方面的了解，用自己的文字进行快速组织介绍，把所有能想到的文字尽量输出出来，不要担心写的好不好，通顺不通顺，你可以理解为列草稿。</p><h3 id="06-花10分钟，将自己的头脑冷静一下"><a href="#06-花10分钟，将自己的头脑冷静一下" class="headerlink" title="06/ 花10分钟，将自己的头脑冷静一下"></a>06/ 花10分钟，将自己的头脑冷静一下</h3><p>对于刚输出的内容，自己的思维可能一直处于一种惯性思维之中。试着将这种思维冷却下来，才可能更加理性的看待问题。</p><h3 id="07-花6分钟，重新省视自己的文案"><a href="#07-花6分钟，重新省视自己的文案" class="headerlink" title="07/ 花6分钟，重新省视自己的文案"></a>07/ 花6分钟，重新省视自己的文案</h3><p>你可以通过大声朗读自己的文案，以及换位思考，假如你是读者，感受如何。另外，尽量使用客户有依据的数字来支撑你的表达，从而提升说服力。</p><h3 id="08-花6分钟，检查自己的表达逻辑"><a href="#08-花6分钟，检查自己的表达逻辑" class="headerlink" title="08/ 花6分钟，检查自己的表达逻辑"></a>08/ 花6分钟，检查自己的表达逻辑</h3><p>检查自己方案的表达逻辑是否合理，以及学会在适当的位置进行段落，可以减轻用户的阅读障碍。如何不知道写符合逻辑的推广文案，可以学习一下<a href="https://baike.baidu.com/item/aida/19650301?fr=aladdin" target="_blank" rel="noopener">aida（营销模式）_百度百科</a></p><h3 id="09-花8分钟，优化文案"><a href="#09-花8分钟，优化文案" class="headerlink" title="09/ 花8分钟，优化文案"></a>09/ 花8分钟，优化文案</h3><p>检查自己的文案，是否存在不通顺、措词不当以及存在错别字的情况，把自己的每一段文案当成一个产品进行精打细磨。</p><h3 id="10-All-done"><a href="#10-All-done" class="headerlink" title="10/ All done"></a>10/ All done</h3><p>到这一步，你能做都已经做了，剩下的就只能看广告在市场中的具体表现效果了。</p><p>而你呢，接下来所要做的事情，就是继续写一篇文案，以此往复，不断提高自己“Writing-》Sell”的文案能力。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cifnews.com/article/28761" target="_blank" rel="noopener">CTA设置11法则，帮卖家提升产品点击率和转化率-雨果网</a></li><li><a href="https://twitter.com/HatchKolby/status/1379557621120794628?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1379590804730126337%7Ctwgr%5E%7Ctwcon%5Es3_&amp;ref_url=https%3A%2F%2Froamresearch.com%2F%2Fapp%2FHackLabs" target="_blank" rel="noopener">(2) Kolby Hatch 在 Twitter: “Great writing can be fast. I’ve written 1,007 ads for @thehustle That’s in the ballpark of 250 different startups. At 150 words an ad, it’s a LOT of writing. You learn to write fast. Here’s my framework for writing a great ad in 61 minutes w/minimal effort 👇” / Twitter</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何用最少的时间写出最漂亮的广告推广文案呢？今天就向你推荐一个写作框架。,点击【ReadMore】，了解更多详情。
    
    </summary>
    
      <category term="Write" scheme="https://www.hackdapp.com/categories/Write/"/>
    
    
  </entry>
  
  <entry>
    <title>交易者应掌握的能力</title>
    <link href="https://www.hackdapp.com/archives/Sun%20Feb%2028%202021%2000:00:00%20GMT+0800%20(China%20Standard%20Time).html"/>
    <id>https://www.hackdapp.com/archives/Sun Feb 28 2021 00:00:00 GMT+0800 (China Standard Time).html</id>
    <published>2021-02-28T10:02:54.000Z</published>
    <updated>2021-04-07T10:00:45.168Z</updated>
    
    <content type="html"><![CDATA[<p>无论是在股市或是币市，我们都希望通过自己的一顿神操作，买到那些可以让自己瞬间反几倍甚至几十倍的股票或数字货币，但现实情况<br>会告诉你，即使是牛市你也能亏钱亏的要死。</p><p>为什么呢？这就不得不想想其中你想赚钱的行为，是一种投机还是投资？</p><p>投机呢，完全可能就是全凭着几个火热大群的fomo情绪，亦或是好巧不巧的几个自己认为重要的小道消息，就认为自己拿到了人生财富密码，知道自己输的底朝天；而投资往往是通过自己对标的物，花精力与时间去研究思考，挖机出它的长期价值，尤其是那些被低估的标的，即使是自己决策失误，也会总结教训，从错误中反思，改进自己的投资方法论，不错失提升自己大脑🧠成长的机会。</p><p>韭菜之所以是韭菜，就因为再每一次决策失误的时候不去学习反思，丧失了每一次成长的机会，慢慢就变成了一根老韭菜。</p><p>所以，在赚钱这条路上，我们慢慢培养总结自己的投资方法论，并在实践过程中不断反思复盘完善自己的投资逻辑。</p><blockquote><p>思考带来决策，决策带来行动，行动改变命运，，行动改变命运！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论是在股市或是币市，我们都希望通过自己的一顿神操作，买到那些可以让自己瞬间反几倍甚至几十倍的股票或数字货币，但现实情况&lt;br&gt;会告诉你，即使是牛市你也能亏钱亏的要死。&lt;/p&gt;
&lt;p&gt;为什么呢？这就不得不想想其中你想赚钱的行为，是一种投机还是投资？&lt;/p&gt;
&lt;p&gt;投机呢，完
      
    
    </summary>
    
      <category term="认知" scheme="https://www.hackdapp.com/categories/%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="认知" scheme="https://www.hackdapp.com/tags/%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>如何提高收益风险比</title>
    <link href="https://www.hackdapp.com/archives/how-to-improve-return-risk-ratio.html"/>
    <id>https://www.hackdapp.com/archives/how-to-improve-return-risk-ratio.html</id>
    <published>2021-02-21T12:56:11.000Z</published>
    <updated>2021-04-07T10:00:45.167Z</updated>
    
    <content type="html"><![CDATA[<p>什么是收益风险比呢?  字面意思不难理解，就是： 收益风险比 = 可能的收益 / 未知的风险。</p><p>为什么需要认识并提升自己的收益风险比呢？ 因为像我这样打工人，除了工资之外，就没有其他收入了，如果被辞职或家里出些什么事，无论是家庭生活质量还是自己的心理焦虑，都会受到极大的生存压力。而投资作为被动收入的一种手段，就可以提升我们在工作单一收入上的安全度，而提升收益风险比，就是在这一基础上能够获得更大的回报。</p><p>那么如何提高收益风险比呢？很简单：<br>一、提高分子值，即：让自己的可能收益的概率更高。那么如何做到呢？比如：筛选优质投资标的；选择合适的投资时机；长线持有，防止频繁操作，被甩下车的可能；<br>二、降低分母值，即：降低投资对自己生活的风险影响程度。如何做呢？比如：设置止损线，尽量让损失控制在自己可以接受的心理价位；按自己的风险承受能力，设置投资金额占总资产的百分比；增加场外赚钱能力，充沛的现金流在一定程序上可以降低自己的投资焦虑。</p><p>通过合理的收益风险比的控制，可以让我们在整个投资过程中，除了降低一些心理焦虑压力，还能获取更高的投资回报，并最终提升我们的家庭生活质量以及风险承受能力。</p><p>2021年，希望自己在数字货币投资领域，能够有个好的收获！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是收益风险比呢?  字面意思不难理解，就是： 收益风险比 = 可能的收益 / 未知的风险。&lt;/p&gt;
&lt;p&gt;为什么需要认识并提升自己的收益风险比呢？ 因为像我这样打工人，除了工资之外，就没有其他收入了，如果被辞职或家里出些什么事，无论是家庭生活质量还是自己的心理焦虑，都会
      
    
    </summary>
    
      <category term="投资" scheme="https://www.hackdapp.com/categories/%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="投资" scheme="https://www.hackdapp.com/tags/%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>C++简单程序入门</title>
    <link href="https://www.hackdapp.com/archives/simple_cpllus_code.html"/>
    <id>https://www.hackdapp.com/archives/simple_cpllus_code.html</id>
    <published>2019-04-04T04:00:00.000Z</published>
    <updated>2021-04-07T09:31:42.557Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* filename: myapp.cpp</span></span><br><span class="line"><span class="comment">   date: 2019-01-28 3:06 PM</span></span><br><span class="line"><span class="comment">   auth: 55269778@qq.com */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;//定义头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//命令空间, 简化后续变量或方法调用。e.g. std::string 等同于 string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> msg = <span class="string">"hi, my first dapp"</span>; <span class="comment">//定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tryit: http://tpcg.io/Tulum1</span></span><br></pre></td></tr></table></figure><p>以上代码便是C++最简单可运行的最小示例。基本包含了在程序结构中所必须的一些语言特性。</p><p>根据上述程序结构，我们可以大致将它拆分成五部分内容：</p><h2 id="1-include-lt-iostream-gt"><a href="#1-include-lt-iostream-gt" class="headerlink" title="1. #include &lt;iostream&gt;"></a>1. <code>#include &lt;iostream&gt;</code></h2><p>头文件定义主要用于引用第三方函数库，通过调用第三方函数可以减少开发代码量，提高开发效率，同时也避免了不必要的重复造轮子。</p><p>比如：通过引用\&lt;cmath>库，可以帮助我们快速使用里面的函数进行一些数学运算。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzmer35re6j30l30j6myt.jpg" alt></p><p>所以，后续我们需要学会便是如何查阅C</p><h2 id="2-int-main"><a href="#2-int-main" class="headerlink" title="2. int main()"></a>2. <code>int main()</code></h2><p><code>main</code>函数区别于其它普通函数之处在于: main函数默认被系统定义为应用入口调用方法。除此之外，与其他函数无任何区别。</p><pre><code>#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;string sayHi(string username){    return string(&quot;hi, &quot;).append(username).append(&quot;!&quot;);}int main(){    cout &lt;&lt; sayHi(&quot;www.hackdapp.com&quot;) &lt;&lt;endl;}//tryit: http://tpcg.io/uHUkzy</code></pre><p>函数定义，其实对于所有编程语言的定义方式大致相同, 都可以表现为以下形式</p><pre><code>&lt;返回类型|void&gt; 方法名(参数定义1, 参数定义2，参数定义...){    //do some stuff    return &lt;返回数据&gt;}</code></pre><p>如果你之前已经在使用其他编程语言，那么应该对于C++其实也可以很好的理解它的程序结构。</p><p>注： 后续我们会详细介绍函数的多种定义及使用方式，包括形参实参、重载以及虚函数等。</p><h2 id="3-string-message-quot-hi-my-first-app-quot"><a href="#3-string-message-quot-hi-my-first-app-quot" class="headerlink" title="3. string message = &quot;hi, my first app&quot;"></a>3. <code>string message = &quot;hi, my first app&quot;</code></h2><p>变量定义，在程序开发过程，往往需要定义一些临时变量，用于存储在数据逻辑处理过程所必须的临时存储。</p><p>而变量的类型，主要分为字符、整型，长/短整型、单精度、双精度、布尔类型以及字符串。<br>我们在实际应用场景中，需要明确了解与知道这些基础数据类型的定义及边界范围，比如，无符号整型、单精度。</p><p>尤其是对数字类型的字段，如果不了解其边界范围，很可能会导致运算溢出等问题，特别是在合约开发过程中，数字溢出很可能导致的便是相当大的经济损失。</p><p>换个角度讲，合理的使用变量类型，也可能在一定程序中节省资源的浪费。因为在EOS合约中存储数据是需要消耗资源的。</p><p>另外，对于变量的名称定义，其名称只能是由数字、字母以及下划线组成且不可能以数字开头，而且根据不同平台，对于名称的长度其实也是存在限制的。</p><h2 id="4-cout-lt-lt-msg-lt-lt-endl"><a href="#4-cout-lt-lt-msg-lt-lt-endl" class="headerlink" title="4. cout &lt;&lt; msg &lt;&lt;endl"></a>4. <code>cout &lt;&lt; msg &lt;&lt;endl</code></h2><p><code>cout</code>是<code>iostream</code>函数库中的一个流数据输出函数，一般用于在程序调用过程向控制台输入一些调试信息；与此对应的是<code>cin</code>, 用于接收输入数据流。</p><p>不过, 在EOS合约中无法调用此函数。举而代之的是，EOSLIB库自己封装的<code>print</code>函数.</p><h2 id="5-单行注解-or-多行注解"><a href="#5-单行注解-or-多行注解" class="headerlink" title="5. //单行注解 or /*多行注解*/"></a>5. <code>//单行注解 or /*多行注解*/</code></h2><p>在程序开发过程，往往需要通过语言描述某个代码文件所要实现的整体功能或者某个函数的功能、参数及约束说明。这时候就需要用到注解。</p><p>而注解同样也所有的编程语言中也大致相同，一般分为单行注释与多行注释。</p><p>单行注释适用于短小的描述某一行运行逻辑；而多行注释多用于描述函数说明以及文件功能说明。</p>]]></content>
    
    <summary type="html">
    
      C++简单程序入门. 以最简单的示例代码，为你拆解其脉络结构。上手C++对你来说，那不是难事。
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>零基础体验EOS入门合约开发</title>
    <link href="https://www.hackdapp.com/archives/try_eoscontract_dev.html"/>
    <id>https://www.hackdapp.com/archives/try_eoscontract_dev.html</id>
    <published>2019-04-03T23:00:00.000Z</published>
    <updated>2021-04-07T09:31:42.557Z</updated>
    
    <content type="html"><![CDATA[<p>本教程主要面向初阶开发人员，目的在于带领大家以最简单的示例合约，通过简单但不失完整的流程，体验整个合约的编译、发布与调用过程，从而让大家从直观角度有个清晰的概念认识。</p><hr><p><strong>版本说明</strong><br>测试网公链版本:    v1.7.0-dirty<br>EOSjS-SDK版本：16.0.9<br>开发组件包(CDT):  1.5.0</p><hr><h2 id="一、帐户管理"><a href="#一、帐户管理" class="headerlink" title="一、帐户管理"></a>一、帐户管理</h2><h3 id="1-Register-EOS-Account"><a href="#1-Register-EOS-Account" class="headerlink" title="1. Register EOS Account"></a>1. Register EOS Account</h3><h4 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h4><p>在进行帐户注册时，需要事先提供一对公私钥地址，以便在注册帐号时进行绑定使用。可通过<a href="https://nadejde.github.io/eos-token-sale/" target="_blank" rel="noopener">EOS Key Generation</a>网站进行公私钥地址生成。<br><img src="http://cdn.hackdapp.com/2019-03-26-061513.png" alt><br><img src="http://cdn.hackdapp.com/2019-03-26-061448.png" alt></p><h4 id="注册帐户"><a href="#注册帐户" class="headerlink" title="注册帐户"></a>注册帐户</h4><p>通过<a href="http://monitor.jungletestnet.io/#home" target="_blank" rel="noopener">Jungle2.0 - EOS Test Network Monitor (CryptoLions.io)</a>网站进行EOS帐户的创建<br><img src="http://cdn.hackdapp.com/2019-03-26-061701.jpg" alt><br>点击图中标红<strong>create account</strong>, 在弹出界面中，填写事先生成的公钥地址<br><img src="http://cdn.hackdapp.com/2019-03-26-062433.jpg" alt><br><img src="http://cdn.hackdapp.com/2019-03-26-063220.jpg" alt><br>见上图中，需要填写三个信息，其中account name主要用于填写我们易于记忆的帐户名称，但其帐户名称长度只允许12位长度，且其组成字符也只能从a-z, 1-5以及一个点符号组成。<br>至于owner public key和 active public key分别对应该帐户owner权限和active权限。如果从安全角度讲，两个权限所对应的公钥地址应该设置成不一样的，这样当active private key丢失的时候，可以使用ower权限对active权限对应的公钥地址进行更换。因为ower和active权限是有层次关系的，只允许低级权限对下次权限进行操作。在不丢失ower私钥的情况下，也可以实现对ower权限地址的更换操作。</p><p>点击<strong>create</strong>, 创建成功后，会显示如下信息<br><img src="http://cdn.hackdapp.com/2019-03-26-063306.jpg" alt></p><h3 id="2-Claim-EOS"><a href="#2-Claim-EOS" class="headerlink" title="2. Claim EOS"></a>2. Claim EOS</h3><p><img src="http://cdn.hackdapp.com/2019-03-26-063552.jpg" alt><br>在<a href="http://monitor.jungletestnet.io/#home" target="_blank" rel="noopener">Jungle2.0 - EOS Test Network Monitor (CryptoLions.io)</a>页面，点击菜单栏中的<strong>Faucet</strong>按钮，会弹出如下界面<br><img src="http://cdn.hackdapp.com/2019-03-26-063708.jpg" alt></p><h3 id="3-Balance-Query"><a href="#3-Balance-Query" class="headerlink" title="3. Balance Query"></a>3. Balance Query</h3><p><img src="2019-03-26%20at%2014.37.jpg" alt><br>在<a href="http://monitor.jungletestnet.io/#home" target="_blank" rel="noopener">Jungle2.0 - EOS Test Network Monitor (CryptoLions.io)</a>页面，点击菜单栏中的<strong>account info</strong>按钮，弹出如下界面：<br><img src="http://cdn.hackdapp.com/2019-03-26-064031.jpg" alt><br>填写帐号名称后，点击<strong>get</strong>按钮, 便可以查到该用户的EOS余额及公钥地址信息。</p><h3 id="4-Install-Chrome-Plugin-Scatter"><a href="#4-Install-Chrome-Plugin-Scatter" class="headerlink" title="4. Install Chrome Plugin: Scatter"></a>4. Install Chrome Plugin: Scatter</h3><h4 id="安装scatter"><a href="#安装scatter" class="headerlink" title="安装scatter"></a>安装scatter</h4><p>在chrome浏览器中安装<a href="https://chrome.google.com/webstore/detail/scatter/ammjpmhgckkpcamddpolhchgomcojkle?hl=zh-CN" target="_blank" rel="noopener">Chrome 网上应用店 - scatter</a>插件。<br><img src="http://cdn.hackdapp.com/2019-04-03-024637.jpg" alt></p><p><strong>注: </strong> 如果Chrome插件商店无法打开，则可以使用<a href="https://chrome-extension-downloader.com/" target="_blank" rel="noopener">Start | Chrome Extension Downloader</a>进行下载。scatter插件地址: <a href="https://chrome.google.com/webstore/detail/scatter/ammjpmhgckkpcamddpolhchgomcojkle?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/scatter/ammjpmhgckkpcamddpolhchgomcojkle?hl=zh-CN</a><br><img src="http://cdn.hackdapp.com/2019-04-03-025150.jpg" alt></p><p>插件安装完成后，可以chrome浏览器中看到如下高亮图标。<br><img src="http://cdn.hackdapp.com/2019-04-03-024247.jpg" alt></p><h4 id="使用scatter"><a href="#使用scatter" class="headerlink" title="使用scatter"></a>使用scatter</h4><ul><li><p>初始化scatter帐户<br>  填写密码，然后点击创建按钮<br>  <img src="http://cdn.hackdapp.com/2019-04-03-025355.jpg" alt><br>  点击创建操作后，会显示如下界面，提示保存12个助记词<br>  <img src="http://cdn.hackdapp.com/2019-04-03-025441.jpg" alt><br>  大家需要保存好这12个助词词，以便于在忘记密码时用助记词进行恢复。注：丢失此助记词则意味着你将永远丢失该帐户。</p></li><li><p>添加测试网络<br>  首先、打开主界面后，点击右上解<strong>系统设置</strong><br>  <img src="http://cdn.hackdapp.com/2019-04-03-025951.jpg" alt><br>  然后，选择网络，新建网络<br>  <img src="http://cdn.hackdapp.com/2019-04-03-030455.jpg" alt><br>  填入测试网络的参数信息，比如: <a href="http://jungle2.cryptolions.io:80" target="_blank" rel="noopener">http://jungle2.cryptolions.io:80</a>、chainid: e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473<br>  chaind的获取方式，可以直接通过<a href="http://jungle2.cryptolions.io/v1/chain/get_info" target="_blank" rel="noopener">http://jungle2.cryptolions.io/v1/chain/get_info</a>进行查询<br>  <img src="http://cdn.hackdapp.com/2019-04-03-031702.jpg" alt></p></li><li>导入公私钥<br>  回到主界面，选择<strong>Key Pairs</strong>， 然后导入之前创建的私钥<br>  <img src="http://cdn.hackdapp.com/2019-04-03-031150.jpg" alt></li><li>绑定EOS帐户<br>  <img src="http://cdn.hackdapp.com/2019-04-03-031446.jpg" alt><img src="http://cdn.hackdapp.com/2019-04-03-031901.jpg" alt> <img src="http://cdn.hackdapp.com/2019-04-03-032105.jpg" alt></li></ul><h3 id="5-Buy-RAM、CPU、NET"><a href="#5-Buy-RAM、CPU、NET" class="headerlink" title="5. Buy(RAM、CPU、NET )"></a>5. Buy(RAM、CPU、NET )</h3><p>访问<a href="https://jungle.eosx.io/tools/ram/buy?symbol=10" target="_blank" rel="noopener">内存交易 - 钱包 - EOSX - Fastest EOS Block Explorer</a>网站，绑定scatter帐号</p><p><img src="2019-03-26%20at%2016.44.jpg" alt><img src="2019-03-26%20at%2016.23.jpg" alt></p><p><strong>购买RAM</strong><br><img src="http://cdn.hackdapp.com/2019-03-26-085239.jpg" alt><br><strong>购买CPU与NET资源</strong><br><img src="http://cdn.hackdapp.com/2019-03-26-085429.jpg" alt></p><h2 id="二、合约开发"><a href="#二、合约开发" class="headerlink" title="二、合约开发"></a>二、合约开发</h2><h3 id="1-编写示例合约"><a href="#1-编写示例合约" class="headerlink" title="1. 编写示例合约"></a>1. 编写示例合约</h3><p>在本地创建一个工程目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~&gt; mkdir -p mycontract/&#123;utils, contracts&#125;</span><br><span class="line">~&gt; tree</span><br><span class="line">.</span><br><span class="line">├── contracts</span><br><span class="line">└── utils</span><br></pre></td></tr></table></figure></p><p>在工程目录contracts文件下，创建hello.cpp,<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~&gt; touch contracts/hello.cpp</span><br></pre></td></tr></table></figure></p><p>打开hello.cpp， 填写以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;eosiolib/eosio.hpp&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">class [[eosio::contract]] hello : public contract &#123;</span><br><span class="line">  public:</span><br><span class="line">      using contract::contract;</span><br><span class="line"></span><br><span class="line">      [[eosio::action]]</span><br><span class="line">      void hi( name user ) &#123;</span><br><span class="line">         <span class="built_in">print</span>( <span class="string">"Hello, "</span>, user);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EOSIO_DISPATCH(hello, (hi))</span><br></pre></td></tr></table></figure></p><h3 id="2-编译合约"><a href="#2-编译合约" class="headerlink" title="2. 编译合约"></a>2. 编译合约</h3><p>该步骤需要用到EOS合约开发所必需的cdt开发工具包， 来完成对示例合约的编译工作。</p><p>1）在本地安装eosio-cpp工具命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap eosio/eosio.cdt //增加仓库</span><br><span class="line">brew install eosio.cdt //安装工具包</span><br></pre></td></tr></table></figure></p><p>注： 可使用<strong>eosin-cpp –help</strong>命令来查看所有参数说明</p><p>2）进行合约编译，生成abi合约描述文件及wasm合约文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eosio-cpp -abigen <span class="string">'contracts/hello.cpp'</span> -o <span class="string">'contracts/hello.wasm'</span> --contract <span class="string">'hackdappcom1'</span></span><br></pre></td></tr></table></figure></p><p>编译完成后，会在工程目录生成hello.abi、hello.wasm两个编译文件。hello.abi就好比webservice中的wsdl描述语言一样，主要用于对合约接口及数据结构进行结构性描述， wasm文件为合约编译后的二进制文件。</p><p><strong>ABI文件详细说明</strong>: <a href="https://www.hackdapp.com/archives/eosdev_contract_abi.html">剖析EOS合约编译ABI文件 | HackDApp</a></p><h3 id="3-发布合约"><a href="#3-发布合约" class="headerlink" title="3. 发布合约"></a>3. 发布合约</h3><h4 id="初始化项目工程，并安装eosjs-sdk"><a href="#初始化项目工程，并安装eosjs-sdk" class="headerlink" title="初始化项目工程，并安装eosjs-sdk"></a>初始化项目工程，并安装eosjs-sdk</h4><p>使用<code>npm init</code>命令对项目进行初始化<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~&gt; npm init</span><br><span class="line">package name: (mycontract)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description:</span><br><span class="line">entry point: (index.js)</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">command</span>:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/nolan/Desktop/mycontract/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"mycontract"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，使用<code>npm install eosjs@16.0.9</code>命令进行eos sdk组件安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~&gt; npm install eosjs@16.0.9</span><br></pre></td></tr></table></figure></p><p>安装完成后， 整个项目工程目录结构显示如下:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~&gt; tree</span><br><span class="line">.</span><br><span class="line">├── contracts//合约文件</span><br><span class="line">├── node_modules//依赖组件</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json//工程配置定义</span><br><span class="line">└── utils//工具库</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure></p><h4 id="编辑合约发布文件：-deploy-js"><a href="#编辑合约发布文件：-deploy-js" class="headerlink" title="编辑合约发布文件： deploy.js"></a>编辑合约发布文件： deploy.js</h4><p>首先，在工程根目录下，创建deploy.js；<br>然后，打开该文件，并填下以下内容；<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const eos = require(<span class="string">'./utils/eossdk'</span>)(&#123;</span><br><span class="line">  chainId: <span class="string">"e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473"</span>,</span><br><span class="line">  httpEndpoint: <span class="string">"http://jungle2.cryptolions.io:80"</span>,</span><br><span class="line">  //更改处一： EOS合约Active权限权限</span><br><span class="line">  keyProvider: <span class="string">"5JxqGao9rzXWBUDnNzALyxaFdmZYXiZ46EzHL4sJkHkryzCFKxu"</span>,// 更改处二： 改为要发布的合约帐户名称</span><br><span class="line">  authorization: <span class="string">'hackdappcom1@active'</span>,</span><br><span class="line">  broadcast: <span class="literal">true</span>,</span><br><span class="line">  sign: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">const &#123;deployContract&#125; = require(<span class="string">'./utils/common'</span>)</span><br><span class="line"></span><br><span class="line">//更改处三：改为要发布的合约帐户名称</span><br><span class="line">deployContract(eos, &#123; account: <span class="string">"hackdappcom1"</span>, contractDir: <span class="string">"./contracts"</span> &#125;).<span class="keyword">then</span>((result) =&gt; &#123;</span><br><span class="line">    console.log(`Deployment successful`, JSON.stringify(result, null , 4))</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">    console.error(`Deployment failed`, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最后，根据自己的帐户信息进行参数更改。</p><p>注：deploy.js文件头引入的两个文件<a href="https://gist.github.com/hackdapp/246bc1b9998e7f0f5b12b04a96585081" target="_blank" rel="noopener">eossdk</a>、<a href="https://gist.github.com/hackdapp/b200b70b1e5d32fa9e7ae1fc082681cc" target="_blank" rel="noopener">common.js</a>可直接点击链接下载，并放入工程目录utils文件夹中。</p><h4 id="执行合约发布"><a href="#执行合约发布" class="headerlink" title="执行合约发布"></a>执行合约发布</h4><p>编辑完成deploy.js相关参数数据， 通过node命令进行合约发布。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node deploy.js</span><br></pre></td></tr></table></figure></p><p>运行命令之后，如果发布成功，会显示以下日志信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Deployment successful</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"broadcast"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"transaction"</span>: &#123;</span><br><span class="line">            <span class="string">"compression"</span>: <span class="string">"none"</span>,</span><br><span class="line">            <span class="string">"transaction"</span>: &#123;</span><br><span class="line">                <span class="string">"expiration"</span>: <span class="string">"2019-04-03T06:50:55"</span>,</span><br><span class="line">                <span class="string">"ref_block_num"</span>: 25564,</span><br><span class="line">                <span class="string">"ref_block_prefix"</span>: 1344811314,</span><br><span class="line">                <span class="string">"max_net_usage_words"</span>: 0,</span><br><span class="line">                <span class="string">"max_cpu_usage_ms"</span>: 0,</span><br><span class="line">                <span class="string">"delay_sec"</span>: 0,</span><br><span class="line">                <span class="string">"context_free_actions"</span>: [],</span><br><span class="line">......</span><br><span class="line">                   <span class="string">"account_ram_deltas"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"account"</span>: <span class="string">"hackdappcom1"</span>,</span><br><span class="line">                            <span class="string">"delta"</span>: -27</span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"except"</span>: null,</span><br><span class="line">                    <span class="string">"inline_traces"</span>: []</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"except"</span>: null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="4-合约调用"><a href="#4-合约调用" class="headerlink" title="4. 合约调用"></a>4. 合约调用</h3><p>在确保合约发布成功之后，开始编写合约调用文件 invoke.js<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~&gt; touch invoke.js</span><br></pre></td></tr></table></figure></p><p>打开invoke.js, 填入以下代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const eos = require(<span class="string">'./utils/eossdk'</span>)(&#123;</span><br><span class="line">  chainId: <span class="string">"e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473"</span>,</span><br><span class="line">  httpEndpoint: <span class="string">"http://jungle2.cryptolions.io:80"</span>,</span><br><span class="line">  keyProvider: <span class="string">"5JxqGao9rzXWBUDnNzALyxaFdmZYXiZ46EzHL4sJkHkryzCFKxu"</span>,</span><br><span class="line">  authorization: <span class="string">'hackdappcom1@active'</span>,</span><br><span class="line">  broadcast: <span class="literal">true</span>,</span><br><span class="line">  sign: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const data = &#123;</span><br><span class="line">actions: [</span><br><span class="line">&#123;</span><br><span class="line">      account: <span class="string">'hackdappcom1'</span>,</span><br><span class="line">      name: <span class="string">'hi'</span>,</span><br><span class="line">      authorization: [&#123;</span><br><span class="line">          actor: <span class="string">'hackdappcom1'</span>,</span><br><span class="line">          permission: <span class="string">'active'</span></span><br><span class="line">      &#125;],</span><br><span class="line">      data: &#123;<span class="string">"user"</span>: <span class="string">"222"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">eos.transaction(data).<span class="keyword">then</span>((result)=&gt;&#123;</span><br><span class="line">    console.log(JSON.stringify(result.processed.action_traces[0].console, null, 4))</span><br><span class="line">  &#125;).catch((err)=&gt;&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>执行调用命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node invoke.js</span><br></pre></td></tr></table></figure></p><p>如果能够正常运行，则会显示以下内容信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello, 222"</span></span><br></pre></td></tr></table></figure></p><p>另外，针对教程中出现的代码，我提供了完整的工程代码示例及文字稿教程。大家可点击链接或者直接克隆到本地进行查看。项目地址: <a href="https://github.com/hackdapp/learn_eos" target="_blank" rel="noopener">https://github.com/hackdapp/learn_eos</a></p><hr><h2 id="可能出现的问题："><a href="#可能出现的问题：" class="headerlink" title="可能出现的问题："></a><strong>可能出现的问题</strong>：</h2><ol><li>如果你没有事先购买RAM资源，可以会提示以下错误信息 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"code"</span>: 500,</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"Internal Service Error"</span>,</span><br><span class="line">  <span class="string">"error"</span>: &#123;</span><br><span class="line">    <span class="string">"code"</span>: 3080001,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ram_usage_exceeded"</span>,</span><br><span class="line">    <span class="string">"what"</span>: <span class="string">"Account using more than allotted RAM usage"</span>,</span><br><span class="line">    <span class="string">"details"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">"account hackdappcom1 has insufficient ram; needs 26318 bytes has 5471 bytes"</span>,</span><br><span class="line">        <span class="string">"file"</span>: <span class="string">"resource_limits.cpp"</span>,</span><br><span class="line">        <span class="string">"line_number"</span>: 213,</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"verify_account_ram_usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试网帐号"><a href="#测试网帐号" class="headerlink" title="测试网帐号"></a>测试网帐号</h2><table><thead><tr><th style="text-align:left">帐户名</th><th style="text-align:left">公钥</th><th style="text-align:left">私钥</th></tr></thead><tbody><tr><td style="text-align:left">hackdappcom1</td><td style="text-align:left">EOS6LTWfM5ffbmjUhvwFnrU5QEBrmkzsRo2eXogr2h9oP8DUuzgAi</td><td style="text-align:left">5JxqGao9rzXWBUDnNzALyxaFdmZYXiZ46EzHL4sJkHkryzCFKxu</td></tr><tr><td style="text-align:left">hackdappcom2</td><td style="text-align:left">EOS6qCqbFLuYK5rGK9LDPzcboLqy4phrUxLXLrhLgXxVBpzLzsJke</td><td style="text-align:left">5Jnw2anG8Zzy6MuCNxvwmaX5Hu4B6de1uzuae5QyRrUFtyfL2Wo</td></tr><tr><td style="text-align:left">hackdappcom3</td><td style="text-align:left">EOS57B3rxRBBUiTyZf9iBxsWyQnvEhq2H95wbBbjdzcLbV1gfJ4zy</td><td style="text-align:left">5Ju2NNc24q3jQ2Yc2JcvwWjtGVeAyuWcNsaNVb37u7cmRW56zgc</td></tr><tr><td style="text-align:left">hackdappcom4</td><td style="text-align:left">EOS7i5Diz2uqXSpvutmV4DftBRrL1XASzxsSdWBGrgzngPoXhT2dk</td><td style="text-align:left">5K6nyWMvpfYnQqLhS545dm53exduJgDBLHMYQ6SCNaPmeHjGZdr</td></tr><tr><td style="text-align:left">hackdappcom5</td><td style="text-align:left">EOS6NcaFvvoekuBjhZLsBVywiMcN7VTVmgvAdA5srgTvQMeDmdiAH</td><td style="text-align:left">5JjN9efKokkgZYno2qjbE9C7WCGbVpPvgNArKDvcjbDic2pRGCS</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://nadejde.github.io/eos-token-sale/" target="_blank" rel="noopener">https://nadejde.github.io/eos-token-sale/</a></li><li><a href="http://monitor.jungletestnet.io/#home" target="_blank" rel="noopener">http://monitor.jungletestnet.io/#home</a></li><li><a href="https://jungle.eosx.io/tools/ram/buy?symbol=10" target="_blank" rel="noopener">https://jungle.eosx.io/tools/ram/buy?symbol=10</a></li><li><a href="https://github.com/hackdapp/learn_eos" target="_blank" rel="noopener">https://github.com/hackdapp/learn_eos</a></li><li><a href="https://chrome-extension-downloader.com/f944f5bf7bc58292048aa5b9bf29dc48/scatter.crx.crx.crx" target="_blank" rel="noopener">https://chrome-extension-downloader.com/f944f5bf7bc58292048aa5b9bf29dc48/scatter.crx.crx.crx</a></li></ol><hr><p>到此，整个EOS合约开发的流程就算介绍完毕。让我们再总结一下整体操作流程：</p><ol><li>生成两对公私地址，并进行EOS帐户注册</li><li>通过jungle网站进行EOS币的领取，并对其进行余额查询</li><li>安装Scatter插件，导入私钥并绑定新身份</li><li>使用新注册的EOS帐户购买RAMCPUNET发布合约所需要的资源</li><li>创建合约测试示例并编译</li><li>编写发布合约脚本，替换合约帐户后进行合约发布</li><li>编写合约方法调用脚本，调用合约中的hi方法进行日志打印。<br>通过七个步骤我们了解了整个EOS合约开发的最简化操作流程。</li></ol><hr><h2 id="欢迎关注HackDApp博客或公众号-HackHook将持续为你分享IndieMaker成长路径、DAPP技术知识、高效Mac使用技巧、底层思维认知。"><a href="#欢迎关注HackDApp博客或公众号-HackHook将持续为你分享IndieMaker成长路径、DAPP技术知识、高效Mac使用技巧、底层思维认知。" class="headerlink" title="欢迎关注HackDApp博客或公众号, HackHook将持续为你分享IndieMaker成长路径、DAPP技术知识、高效Mac使用技巧、底层思维认知。"></a><strong>欢迎关注HackDApp博客或公众号</strong>, HackHook将持续为你分享IndieMaker成长路径、DAPP技术知识、高效Mac使用技巧、底层思维认知。</h2><p>我的博客:     <a href="https://www.hackdapp.com/">https://www.hackdapp.com/</a><br>我的github:   <a href="https://github.com/hackdapp" target="_blank" rel="noopener">https://github.com/hackdapp</a><br>我的哔哩哔哩:   <a href="https://space.bilibili.com/17360859" target="_blank" rel="noopener">https://space.bilibili.com/17360859</a><br>我的微信公众号: hackdapp<br><img src="http://cdn.hackdapp.com/2019-04-03-mysign.jpg" alt></p><h2 id="IndieMakers-https-www-indiemakers-cn"><a href="#IndieMakers-https-www-indiemakers-cn" class="headerlink" title="IndieMakers:  https://www.indiemakers.cn"></a>IndieMakers:  <a href="https://www.indiemakers.cn" target="_blank" rel="noopener">https://www.indiemakers.cn</a></h2><p>联系邮箱：<a href="mailto:55269778@qq.com" target="_blank" rel="noopener">55269778@qq.com</a></p>]]></content>
    
    <summary type="html">
    
      本教程主要面向初阶开发人员，目的在于带领大家以最简单的示例合约，通过简单但不失完整的流程，体验整个合约的编译、发布与调用过程，从而让大家从直观角度有个清晰的概念认识。
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="eoscontract" scheme="https://www.hackdapp.com/tags/eoscontract/"/>
    
      <category term="eos dev" scheme="https://www.hackdapp.com/tags/eos-dev/"/>
    
  </entry>
  
  <entry>
    <title>巧用HistoryApiAction实现对链数据的存储与查询</title>
    <link href="https://www.hackdapp.com/archives/eosdev_datastorage_historyaction.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_datastorage_historyaction.html</id>
    <published>2019-03-13T08:36:13.000Z</published>
    <updated>2021-04-07T09:31:42.556Z</updated>
    
    <content type="html"><![CDATA[<p>在开发EOS DApp智能合约时，我们都知道可以使用<code>multi_index</code>来对合约数据的存储与查询，但合约的存储是需要消耗一定的资源的，而且随着用户的增长往往会导业务数据会越来越大，从而导致合约需要更多的资源来支撑其数据。</p><p>有时我们可以通过业务设计，让业务数据得到即时清理及资源释放。但大多数情况下，业务数据是不允许清理的，那么针对这种情况是否有其他办法来降低对合约存储资源的消耗呢？</p><p>那么，今天分享的方案就是：借用EOS链提供的<code>history_api_action</code>插件服务、内部合约Action调用来完成对业务数据的存储与查询。</p><p>举个🌰️：<br>在去中心化交易所中，往往搓合成功会产生大量的成交订单，那保存在合约数据库中肯定是不合适的，所以可以在搓合方法中通过调用内部日志方法的形式，通过交易日志来将订单数据写入区块中；然后通过EOS节点提供的<a href="https://developers.eos.io/eosio-nodeos/v1.4.0/reference#get_actions-1" target="_blank" rel="noopener">查询历史action接口</a>，查询合约日志数据并增量同步到中心化数据库。</p><p>下面，我们将通过具体的代码示例来帮助大家理解整个过程：</p><hr><p><strong>首先</strong>，我们新创建一个合约(dexchange.hpp/dexchange.cpp)；<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//dexchange.hpp</span><br><span class="line"><span class="comment">#include &lt;eosiolib/eosio.hpp&gt;</span></span><br><span class="line"><span class="comment">#include &lt;eosiolib/print.hpp&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">CONTRACT dexchange : public contract &#123;</span><br><span class="line">  public:</span><br><span class="line">    using contract::contract;</span><br><span class="line">    dexchange(eosio::name receiver, eosio::name code, datastream&lt;const char*&gt; ds):contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    [[eosio::action]]</span><br><span class="line">    void executetrade(uint64_t pair_id, uint64_t sell_order_id, uint64_t buy_order_id);</span><br><span class="line"></span><br><span class="line">    [[eosio::action]]</span><br><span class="line">    void <span class="built_in">log</span>(uint64_t deal_price, uint64_t quantity, uint64_t sell_order_id, uint64_t buy_order_id);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EOSIO_DISPATCH(dexchange, (executetrade)(<span class="built_in">log</span>))</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/2b68242019242bdd12f174208e39e7d2</span><br></pre></td></tr></table></figure></p><p><strong>然后</strong>，定义并实现两个方法：executetrade、log。 <code>executetrade</code>合约方法负责搓合业务，当搓合业务处理完之后调用<code>log</code>方法，通过交易信息将参数调用数据写入区块中；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//filename: dexchange.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">#include "dexchange.hpp"</span></span><br><span class="line"></span><br><span class="line">void dexchange::executetrade(uint64_t pair_id, uint64_t sell_order_id, uint64_t buy_order_id)&#123;</span><br><span class="line">  uint64_t deal_price = 1200;</span><br><span class="line">  uint64_t quantity = 10000;</span><br><span class="line"></span><br><span class="line">  action(</span><br><span class="line">      permission_level&#123; _self, <span class="string">"active"</span>_n &#125;,</span><br><span class="line">      _self, <span class="string">"log"</span>_n,</span><br><span class="line">      std::make_tuple(deal_price, pair_id, sell_order_id, buy_order_id)</span><br><span class="line">  ).send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dexchange::<span class="built_in">log</span>(uint64_t deal_price, uint64_t quantity, uint64_t sell_order_id, uint64_t buy_order_id)&#123;</span><br><span class="line">  require_auth( _self );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/ea6ec431a57faee3a2823cfeee406efd</span><br></pre></td></tr></table></figure><p>从以上示例可以看出，合约log日志方法其实并不需要做任何业务逻辑处理。只需要间接被调用，便可将我们需要的业务数据通过交易的形式记录在区块中，而不会浪费我们的合约存储空间，也不需要担心资源释放的问题。</p><p><strong>下一步</strong>、发布智能合约，并调用一次<code>executetrade</code>合约方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发布合约至hackdappexch合约帐户</span><br><span class="line">&gt; cleos <span class="built_in">set</span> contract hackdappexch contracts/ -p  hackdappexch@active</span><br><span class="line"></span><br><span class="line">//执行合约方法</span><br><span class="line">&gt; cleos push action hackdappexch executetrade <span class="string">'[1,2,3]'</span> -p hackdappexch@active</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，通过EOS链节点提供的<a href="https://developers.eos.io/eosio-nodeos/v1.4.0/reference#get_actions-1" target="_blank" rel="noopener">RPC服务</a>，进行历史action数据查询，通过数据过滤找到我们的日志方法及参数数据。</p><p>在确保之前的操作都成功之后，我们使用curl命令查询其对应服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --request POST \</span><br><span class="line">  --url https://localhost:8888/v1/<span class="built_in">history</span>/get_actions \</span><br><span class="line">  --header <span class="string">'content-type: application/x-www-form-urlencoded; charset=UTF-8'</span> \</span><br><span class="line">  --data <span class="string">'&#123;"pos":-1,"offset":-10,"account_name":"hackdappexch"&#125;'</span></span><br></pre></td></tr></table></figure><p>通过此接口查询出来的数据不仅仅是<code>log</code>合约方法数据，可能还会存在该合约的其他方法事件，需要根据情况再过滤一次数据。</p><p><img src="http://cdn.hackdapp.com/2019-03-13-080641.jpg" alt></p><p><strong>补充说明</strong></p><p>如果你在本地曾经搭建过EOS私链的化，那么或许看到过，EOS启动时是可以配置不同插件。而其中有一个插件<code>history_api_plugin</code>，就是用于监听并存储合约方法的调用信息；另外启动链节点时，是可以按规划自由指定所要监听的合约帐户及方法，如： <code>--filter-on hackdappexch::log</code>, 该参数配置表示只监听hackdappexch合约中的log方法。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodeos -e -p eosio -d /mnt/dev/data \</span><br><span class="line">  --config-dir /mnt/dev/config \</span><br><span class="line">  --http-validate-host=<span class="literal">false</span> \</span><br><span class="line">  --plugin eosio::producer_plugin \</span><br><span class="line">  --plugin eosio::chain_api_plugin \</span><br><span class="line">  --plugin eosio::http_plugin \</span><br><span class="line">  --plugin eosio::history_api_plugin \</span><br><span class="line">  --http-server-address=0.0.0.0:8888 \</span><br><span class="line">  --access-control-allow-origin=* \</span><br><span class="line">  --contracts-console \</span><br><span class="line">  --filter-on hackdappexch:<span class="built_in">log</span>: \</span><br><span class="line">  --max-transaction-time=1000 \</span><br><span class="line">  --verbose-http-errors &amp;</span><br></pre></td></tr></table></figure><p>如以上EOS节点启动命令，就展示了启动一个EOS节点的具体参数配置。其中，<code>--filter-on</code>参数便是指定只监听记录<code>hackdappexch</code>合约的<code>log</code>方法调用数据。</p><p>所以，当我们要通过链节点RPC服务查询合约方法历史调用数据时，需要先确认提供RPC服务的节点是否开启了<code>history_api_plugin</code>插件，以及自己所要查询的合约是否在其过滤规则之中。</p><hr><p><strong>小结</strong></p><p>通过本篇文章，我们学会了利用<strong>内部合约方法调用</strong> ➕️ <strong>链节点历史Action查询</strong>的方式实现业务数据的另一种数据存储与查询方案。</p><hr><blockquote><p>在教程中如出现错误🐛或不易理解的知识点，欢迎加我微信指正!<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote><p><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1625.JPG-blog" style="display: inline;"><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1626.jpg-blog" style="display: inline; "></p><hr><h3 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a><strong>changelog</strong></h3><p>2019-03-13 <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang</a></p><ul><li>初次发稿</li></ul>]]></content>
    
    <summary type="html">
    
      在开发EOS DApp智能合约时，我们都知道可以使用`multi\\_index\_`来对合约数据的存储与查询，但合约的存储是需要消耗一定的资源的，而且随着用户的增长往往会导业务数据会越来越大，从而导致合约需要更多的资源来支撑其数据增长。那么是否有一种更好的方式来降低某些场景的资源消耗呢？那么，今天将为你分享一种数据存储方案： 借用EOS链提供的`history_api_action\_`插件、`内部合约Action调用`来完成对业务数据的存储与查询。HackDApp愿与你分享！
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="合约数据存储" scheme="https://www.hackdapp.com/tags/%E5%90%88%E7%BA%A6%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="history action" scheme="https://www.hackdapp.com/tags/history-action/"/>
    
      <category term="inline action" scheme="https://www.hackdapp.com/tags/inline-action/"/>
    
  </entry>
  
  <entry>
    <title>使用EOS.js发布EOS智能合约</title>
    <link href="https://www.hackdapp.com/archives/eosdev_deploycontract_eosjs.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_deploycontract_eosjs.html</id>
    <published>2019-03-12T10:59:46.000Z</published>
    <updated>2021-04-07T09:31:42.556Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的EOS合约开发文章，你可能学会了如何通过EOS系统命令<strong>cleos set contract</strong>的方式进行智能合约的发布与升级。</p><p>但在开发过程中，可能有的同学持续在命令容器与开发IDE间频繁切换，对开发效率有一定程序的影响，那是否有一种更好的方式帮助我们在一个窗口里快速发布合约呢？</p><p>那么本文将带你了解<strong>如何通过EOS.js进行智能合约的发布</strong>。</p><p><img src="http://cdn.hackdapp.com/2019-03-12-083806.jpg" alt><br>如上图所示，在进行合约发布时，需要用到eos系统合约中的两个方法：setcode、setabi。而这两个方法分别会用到智能合约编译后的两个文件： *.wasm、*.abi。</p><p><strong>注意</strong> ： 本文示例中使用的eosjs的版本为<code>16.0.9</code>。</p><p><strong>首先</strong>，需要初始化EOS-SDK实例。 事先准备好初始化SDK所必需的参数：</p><ul><li>chainid<br>  所要发布的目标EOS链chainid. 例如：正式chainid: aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906; jungle测试网chainid: e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473等等</li><li>httpEndpoint<br>  EOS链环境http接口地址。 例如: <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a></li><li>keyProvider<br>  合约帐户私钥，主要用于交易签名。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//config.js</span><br><span class="line">const Eos = require(<span class="string">'eosjs'</span>)</span><br><span class="line"></span><br><span class="line">const eos = Eos(&#123;</span><br><span class="line">    chainId: <span class="string">"cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f"</span>,</span><br><span class="line">    httpEndpoint: <span class="string">"http://localhost:8888"</span>,</span><br><span class="line">    keyProvider: <span class="string">"5K7mtrinTFrVTduSxizUc5hjXJEtTjVTsqSHeBHes1Viep86FP5"</span>,</span><br><span class="line">    broadcast: <span class="literal">true</span>,</span><br><span class="line">    sign: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    eos,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/hackdapp/2522411b98b1acdadc0d842f712ca6e0</span><br></pre></td></tr></table></figure><p><strong>下一步</strong>，需要代码实现对合约文件夹中的.wasm及.abi文件的读取；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getDeployableFilesFromDir(dir) &#123;</span><br><span class="line">    const dirCont = fs.readdirSync(dir)</span><br><span class="line">    const wasmFileName = dirCont.find(filePath =&gt; filePath.match(/.*\.(wasm)$/gi))</span><br><span class="line">    const abiFileName = dirCont.find(filePath =&gt; filePath.match(/.*\.(abi)$/gi))</span><br><span class="line">    <span class="keyword">if</span> (!wasmFileName) throw new Error(`Cannot find a <span class="string">".wasm file"</span> <span class="keyword">in</span> <span class="variable">$&#123;dir&#125;</span>`)</span><br><span class="line">    <span class="keyword">if</span> (!abiFileName) throw new Error(`Cannot find an <span class="string">".abi file"</span> <span class="keyword">in</span> <span class="variable">$&#123;dir&#125;</span>`)</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        wasmPath: path.join(dir, wasmFileName),</span><br><span class="line">        abiPath: path.join(dir, abiFileName),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/69b29103e5cc114f4478390076d8ad39</span><br></pre></td></tr></table></figure><p><strong>然后</strong>，通过调用eos实例，分别执行系统合约的setcode/setabi方法，从而达到智能合约的发布；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> deployContract(&#123; account, contractDir &#125;) &#123;</span><br><span class="line">  const &#123; wasmPath, abiPath &#125; = getDeployableFilesFromDir(contractDir)</span><br><span class="line"></span><br><span class="line">  const wasm = fs.readFileSync(wasmPath)</span><br><span class="line">  const abi = fs.readFileSync(abiPath)</span><br><span class="line"></span><br><span class="line">  const codePromise = eos.setcode(account, 0, 0, wasm)</span><br><span class="line">  const abiPromise = eos.setabi(account, JSON.parse(abi))</span><br><span class="line">  <span class="built_in">return</span> Promise.all([codePromise, abiPromise])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/69b29103e5cc114f4478390076d8ad39</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，调用deployContract方法，测试合约发布功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deployContract(&#123; account: <span class="string">"eosio.token"</span>, contractDir: <span class="string">"./contract"</span> &#125;).<span class="keyword">then</span>((result) =&gt; &#123;</span><br><span class="line">    console.log(`Deployment successful`, JSON.stringify(result, null , 4))</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">    console.error(`Deployment failed`, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/69b29103e5cc114f4478390076d8ad39</span><br></pre></td></tr></table></figure><hr><p><strong>小结</strong></p><p>通过本文我们学习了如何通过eos实例的setcode/setabi方法将合约编译文件快速发布到指定链环境。</p><p>另外，如果为了提高发布合约效率，我们还可以在package.json中定义发布合约的运行脚本，并配合IDE工具中的快捷键，便可达到开发效率的进一步提升。</p><hr><blockquote><p>在教程中如出现错误🐛或不易理解的知识点，欢迎加我微信指正!<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote><p><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1625.JPG-blog" style="display: inline;"><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1626.jpg-blog" style="display: inline; "></p><p>注： 有想了解<strong>愿码全思维IT工程师加速器</strong>的朋友，可以扫码加群咨询。</p><hr><h3 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a><strong>changelog</strong></h3><p>2019-03-12 <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang</a></p><ul><li>初次发稿</li></ul>]]></content>
    
    <summary type="html">
    
      之前我们曾经介绍过如何使用EOS的系统命令(cleos set contract)发布智能合约，那么今天将分享另外一种方式：使用eosjs-sdk发布合约。在此基础上，可以通过配置package.json脚本以及IDE快捷链，可以快速提升DApp开发效率。HackDApp愿与你分享！
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
      <category term="deploy contract" scheme="https://www.hackdapp.com/tags/deploy-contract/"/>
    
  </entry>
  
  <entry>
    <title>剖析EOS合约编译ABI文件</title>
    <link href="https://www.hackdapp.com/archives/eosdev_contract_abi.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_contract_abi.html</id>
    <published>2019-03-07T11:33:14.000Z</published>
    <updated>2021-04-07T09:31:42.555Z</updated>
    
    <content type="html"><![CDATA[<p>相信不少开发者朋友在进行EOS合约开发时，都看到发布智能合约时的ABI文件。那ABI文件到底是什么东西？在EOS公链环境中到底发挥怎么样的作用呢以及如何解读ABI文件内容呢？</p><p>那么本章节将带你了解ABI文件与智能合约间的关系以及了解并学会ABI文件的编写。</p><p><strong>ABI</strong>， 简称(Application Binary Interface), 是一个基于JSON语言的接口描述文档，用于描述EOS合约以及如何对合约方法进行调用。如果大家曾经接触过websocket、avro、hession、thrift等这类技术的化，那么是大体逻辑是相向的。比如websocket所提供的wsdl其实也是对websocket本身对外所提供服务的接口描述。</p><p>在EOS合约，ABI文件是由开发组件eosio.cdt工具包中的eosio-cpp命令执行所生成的文件。但在实际开发时，时常会碰到一些情况无法生成ABI文件。因为在合约开发，我们往往会根据业务自定义一些数据结构，或者使用一些第三方方法，而eosio.cdt本身对所有特隆并不是支持的很完善，所以时常导致编译失败，这时就需要我们理解ABI是如何定义智能合约的，以便于我们定制化修改自己的合约描述。</p><p>ABI文件结构是由什么组成的呢？让我们先看一个示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"version"</span>: <span class="string">"eosio::abi/1.0"</span>,</span><br><span class="line">   <span class="string">"types"</span>: [],</span><br><span class="line">   <span class="string">"structs"</span>: [],</span><br><span class="line">   <span class="string">"actions"</span>: [],</span><br><span class="line">   <span class="string">"tables"</span>: [],</span><br><span class="line">   <span class="string">"ricardian_clauses"</span>: [],</span><br><span class="line">   <span class="string">"abi_extensions"</span>: [],</span><br><span class="line">   <span class="string">"___comment"</span> : <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面json示例展示了一个标准智能合约所应具备的完整属性定义。</p><p><strong>数据类型(type)</strong><br>在项目开发过程，有时为了便于代码的理解，我们会将一些通用数据类型或数据结构进行别名定义，用一个在业务场景中更加贴合业务的名称代替。在<code>types</code>数组中便是对这种情况的定义描述。</p><p>比如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"new_type_name"</span>: <span class="string">"age"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"int"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"new_type_name"</span>: <span class="string">"name"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"string"</span> //此处user为自定义数据结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于合约内嵌类型，是不会在此展示的。诸如： uint64_t、name、asset、symbol等。下图展示了EOS合约所支持的所有内置数据类型<br><img src="http://image.chaindesk.cn/2019-03-07-095044.jpg" alt></p><hr><p><strong>结构体(struct)</strong><br>在业务处理逻辑中，为了方便数据的传输与调用，往往我们会对针对业务数据进行建模并以结构体的形式展现。同样，它也需要在ABI文件中进行描述。</p><p>比如: eosio.token合约中的account结构体定义</p><ul><li><p>ABI文件定义</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"account"</span>,</span><br><span class="line">    <span class="string">"base"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"fields"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"balance"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"asset"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>eosio.token.hpp实现</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct account &#123;</span><br><span class="line">asset    balance;</span><br><span class="line"></span><br><span class="line">uint64_t primary_key()const &#123;</span><br><span class="line"><span class="built_in">return</span> balance.symbol.code().raw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>另外，需要注意的就是除了以上这种结构体定义，其实还存在一种隐性结构体，即：合约方法参数<br>示例：</p><ul><li><p>eosio.token.hpp中transfer方法定义</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void transfer( name    from,</span><br><span class="line">                        name    to,</span><br><span class="line">                        asset   quantity,</span><br><span class="line">                        string  memo );</span><br></pre></td></tr></table></figure></li><li><p>eosin.token合约中transfer方法在ABI文件中定义</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"transfer"</span>,</span><br><span class="line"><span class="string">"base"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"fields"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"from"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"to"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"quantity"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"asset"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"memo"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看出，隐性结构体与前面所定义显性结构体定义是并没有什么不同，只是在智能合约业务逻辑中，我们仅用到显性结构体来存储我们的业务数据进行逻辑判断。</p><hr><p><strong>方法(Action)</strong><br><code>Action</code>数组主要用于描述外部可调用的方法列表以及具体的参数列表。在智能合约中，如果需要对外公开合约方法，往往会在合约头文件中进行如下定义：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[eosio::action]]</span><br><span class="line">void transfer(name from,name to, asset quantity, string memo);</span><br></pre></td></tr></table></figure></p><p>而ABI的表现形式为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"transfer"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"transfer"</span>,</span><br><span class="line">    <span class="string">"ricardian_contract"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述描述可以看出，在方法的类型定义关联了前面的隐性结构体类型。虽然在此处，方法名与隐性结构体类型命名一致，但实际情况并不一定非要相同。</p><hr><p><strong>表定义(Table)</strong><br>关于表的ABI定义，相比其他几种定义要稍复杂一些。具体JSON定义如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"index_type"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"key_names"</span> : [],</span><br><span class="line">  <span class="string">"key_types"</span> : []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JSON中字段说明如下:</p><ul><li>name<br>  合约初始化表时所要使用的名称</li><li>type<br>  表对应的数据结构体。也就是前面所说的显性结构体类型</li><li>index _type<br>  此类型为表主键类型</li><li>key _names<br>  索引字段列表</li><li>key_types<br>  索引字段数据类型列表。数据长度与索引字段列表长度一致。需要说明的是索引字段类型，只支持uint64_t,uint128 _t,uint256 _t,double,long double五种类型<br>示例：eosio.token合约中的accounts表</li><li><p>ABI表定义</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"accounts"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"account"</span>,</span><br><span class="line">    <span class="string">"index_type"</span>: <span class="string">"i64"</span>,</span><br><span class="line">    <span class="string">"key_names"</span>: [<span class="string">"primary_key"</span>],</span><br><span class="line">    <span class="string">"key_types"</span>: [<span class="string">"uint64"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表合约代码</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct [[eosio::table]] account &#123;</span><br><span class="line">    asset    balance;</span><br><span class="line"></span><br><span class="line">    uint64_t primary_key()const &#123; <span class="built_in">return</span> balance.symbol.code().raw(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>从表合约代码可以看来，只需要在数据结构体代码中添加eosio-table标签就可以完成对表的定义操作。</p><p>之所以提供多索引的实现，主要还是为了应对业务场景中不同维度的数据查询，而且支持按升序或降序的遍历方式处理业务。</p><hr><p><strong>ricardian条款(ricardian_clauses)</strong><br>该数组主要用于定义一种基于文本的合约宪法。通过其与智能合约的整合，来解决一些无法通过程序来判定的情况。</p><p>示例如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"ricardian_clauses"</span>: [&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"Warranty"</span>,</span><br><span class="line">      <span class="string">"body"</span>: <span class="string">"WARRANTY. The invoker of the contract action shall uphold its Obligations under this Contract in a timely and workmanlike manner, using knowledge and recommendations for performing the services which meet generally acceptable standards set forth by EOS.IO Blockchain Block Producers.\n\n"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"Default"</span>,</span><br><span class="line">      <span class="string">"body"</span>: <span class="string">"DEFAULT. The occurrence of any of the following shall constitute a material default under this Contract: \n\n"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"Remedies"</span>,</span><br><span class="line">      <span class="string">"body"</span>: <span class="string">"REMEDIES. In addition to any and all other rights a party may have available according to law, if a party defaults by failing to substantially perform any provision, term or condition of this Contract, the other party may terminate the Contract by providing written notice to the defaulting party. This notice shall describe with sufficient detail the nature of the default. The party receiving such notice shall promptly be removed from being a Block Producer and this Contract shall be automatically terminated. \n  \n"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>我们可以针对智能合约或者具体的合约方法，附加上对应的文本合约描述。比如针对方法的文本合约定义:</p><ul><li><p>ABI定义</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"actions"</span>: [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"hi"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"hi"</span>,</span><br><span class="line">    <span class="string">"ricardian_contract"</span>: <span class="string">"# CONTRACT FOR hello::hi## ACTION NAME: hi\n### Parameters### Parameters\nInput parameters:Input parameters:\n\n* `user` (string to include in the output)* `user` (string to include in the output)\n\nImplied parameters: Implied parameters: \n\n* `account_name` (name of the party invoking and signing the contract)* `account_name` (name of the party invoking and signing the contract)\n\n### Intent### Intent\nINTENT. The intention of the author and the invoker of this contract is to print output. It shall have no other effect.INTENT. The intention of the author and the invoker of this contract is to print output. It shall have no other effect.\n\n### Term### Term\nTERM. This Contract expires at the conclusion of code execution.TERM. This Contract expires at the conclusion of code execution.\n"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li><li><p>代码及文件定义（hello.hi_rc.md）</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CONTRACT FOR hello::hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ACTION NAME: hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Parameters</span></span><br><span class="line">Input parameters:</span><br><span class="line"></span><br><span class="line">* `user` (string to include <span class="keyword">in</span> the output)</span><br><span class="line"></span><br><span class="line">Implied parameters:</span><br><span class="line"></span><br><span class="line">* `account_name` (name of the party invoking and signing the contract)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Intent</span></span><br><span class="line">INTENT. The intention of the author and the invoker of this contract is to <span class="built_in">print</span> output. It shall have no other effect.</span><br><span class="line"></span><br><span class="line"><span class="comment">### Term</span></span><br><span class="line">TERM. This Contract expires at the conclusion of code execution.</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>ABI Extensions</strong><br>该功能将允许用户进行自定义区块扩展， 包括对数据的签名、编码等。不过现在该属性暂未被应用支持。</p><hr><p>到此，相信大家对于整个ABI文件的结构应该有了大体的认识与理解。这样大家可以在研究其他智能合约时，可以首先阅读对方的ABI文件，就可以熟悉对方的整体接口框架。</p><hr><blockquote><p>在教程中如出现错误🐛或不易理解的知识点，欢迎加我微信指正!<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote><hr><p><strong>changelog</strong><br>2019-03-07 <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang</a></p><ul><li>初次发稿</li></ul>]]></content>
    
    <summary type="html">
    
      每个EOS合约开发者肯定都知道ABI文件，但却不一定都知道ABI内部属性是什么，具体作用。本文hackdapp将带你一探ABI究竟。HackDApp愿与你分享！
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
      <category term="EOS完全开发手册" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    
      <category term="eos smart abi" scheme="https://www.hackdapp.com/tags/eos-smart-abi/"/>
    
  </entry>
  
  <entry>
    <title>重塑思维：自律 VS 习惯</title>
    <link href="https://www.hackdapp.com/archives/rebuildbrain_habit.html"/>
    <id>https://www.hackdapp.com/archives/rebuildbrain_habit.html</id>
    <published>2019-02-14T07:46:39.000Z</published>
    <updated>2021-04-07T09:31:42.555Z</updated>
    
    <content type="html"><![CDATA[<p><strong>自律使我压抑，习惯助我成长。</strong> 自律与习惯，其实目标都是一致的，只是所产生的行动动力源是不相同的。</p><p>相信每个人都在不停的思考一个问题，“我如何才能使明天的自己比今天的自己更加优秀一些呢？”</p><p>为了让自己变得更好，我们去总结规律，改变自我认知，希望能从不断的思维升级过程中，锻造出属于自己的思维工具，培养及丰富问题症结的方案库。</p><p>为了让自己变得更好，我们需要靠意志去坚持去做一件让自己变得优秀的事情，但你发现一段时间之后，这件事不了了知，扔那儿放下了，因为这样的事在我的人生当中简直太熟悉不过了。</p><p>相反，有一些行为却长期固化下来了，比如我们的一些日常洗漱习惯，即使你中途有一段时间没去做，那你也不会放弃这件事。</p><p>当某一种行为已经成为你的习惯时，如果你有意识的去观察一下，会发现一些许规律。比如：刷牙，可能现在没有不早晚刷牙的童鞋吧。不妨想一想这个行为大家保持了多少年，到现在是否还需要各种精神动力去推着自己去做这个事吗？</p><p>明显不需要，可以说这已经是写入自己骨头里的一种惯性行为，你要是不注意都不发现它原来其实就是一个号的学习榜样。因为它太习以为常了，平常的都忘掉它的存在。</p><p>那既然刷牙可以养成习惯，那我们其他行为为啥就不能养成一种习惯呢？</p><p>首先，处于习惯性的行为执行过程并不会让你特别有心理负担；<br>其次，习惯中的行为并不会消耗自己稀缺的精力；<br>最后，行为关联及导向性。也就是习惯行为之间的联动开关。比如：洗漱的时候总能与刷牙这件事产生一定的链接，而这个链接往往就是我们通过意识去不断增强脑回路而形成的。</p><p>之所以总结这些，就是因为我身上的一件事，当时看李笑来的专栏里曾经提到一种感受，就是“不做这件事就难受”。 当时是在是无法理解这种状态，除了吃饭这件事，找不出天天不做就难受的事来，当你无法从自身找到可以参考的例子时，你总是无法理解其概念。</p><p>直到我发现身上这件事，<code>刮胡子</code>。对，你没看错，就是刮胡子。</p><p>为什么讲呢？因为之前总是用电动剃须刀，总是容易忘记用，时做时不做的，而且刮的也不是太干净。直到有一天看到京东做活动卖手动剃须刀，想着买来试一试，但当时也犹豫，每天早上用这个会不会特花时间啊。</p><p>但事实证明，相比电动剃须刀，手动的虽然要麻烦一些，时间也要多花费一些。但这件事我却坚持了一年，直至今日从心理感受来讲，自己并没有感觉每天要逼着自己去做这件事，而是很自觉的每天洗漱后自动进入刮胡子状态。</p><p>为什么会这样呢？因为每一次刮完胡子，对着镜子一照，感觉干净清爽，漂亮，帅气。让我从内心看到一个舒服的自己，这算不算是一种仪式感呢。</p><p>后来，我总结了一下习惯养成的一个关键因素：持续的心理反馈。反馈可以让我们感受到变化与进步，或是一种心理满足；而持续性一来可以增强行为的动力，二过可以慢慢促进脑回路的链接建立。</p><p>那么，如何建立自己的习惯养成路径呢？那就是</p><ol><li>先制定一个你绝对认可其价值的目标；</li><li>在意识中建立诱导因子，也就是你需要在已形成的习惯之中，建立一个与新行动的触感连接；</li><li>持续反馈，每天都要总结，让自己内心见证成长，而后通过持续达到巩固行动的动力。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好的习惯、应用技巧及思维方式是可以产生复利效应价值的，关键在于它不是形式上的应用，不是为技巧而技巧，一定是在我们的生活或工作实际场景中解决实际问题，并以此不断反馈价值收获，而持续的价值收益又会加强我们执行的动力，最终形成一个正向向上的良性循环♻️。</p><p>执行力其实是落实行动的第一要素，所以我们需要学会如何去补充这项能源。而最好的方式就是让自己认可这件事的价值。并且能够在做事的过程中，有深刻的反馈与心理感受，学会记录自己的心理变化。</p><p>最后，通过不断的执行与反馈，增强我们的脑回路链接。久而久之，就会成为我们的习惯。</p>]]></content>
    
    <summary type="html">
    
      本周最大的收获就是：搞清楚自律与习惯间的转换逻辑。明白靠自律去约束自己只能不断内耗意志力，相反如果通过打造系统逻辑，形成习惯便可从根本上提高效率。因为本身习惯不消耗意志力而是一种肌肉反应能力。HackDApp愿与你分享！
    
    </summary>
    
      <category term="思维认知" scheme="https://www.hackdapp.com/categories/%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="重塑思维" scheme="https://www.hackdapp.com/tags/%E9%87%8D%E5%A1%91%E6%80%9D%E7%BB%B4/"/>
    
      <category term="自律与习惯" scheme="https://www.hackdapp.com/tags/%E8%87%AA%E5%BE%8B%E4%B8%8E%E4%B9%A0%E6%83%AF/"/>
    
      <category term="思维认知" scheme="https://www.hackdapp.com/tags/%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++基础语法（EOS完全开发指南）</title>
    <link href="https://www.hackdapp.com/archives/eosdev_cplus_basic.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_cplus_basic.html</id>
    <published>2019-01-28T10:16:50.000Z</published>
    <updated>2021-04-07T09:31:42.554Z</updated>
    
    <content type="html"><![CDATA[<p><code>Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* filename: myapp.cpp</span></span><br><span class="line"><span class="comment">   date: 2019-01-28 3:06 PM</span></span><br><span class="line"><span class="comment">   auth: zhangliang&lt;zhangliang@cldy.org&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //定义头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    <span class="comment">//命令空间, 简化后续变量或方法调用。e.g. std::string 等同于 string</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">"hi, my first dapp"</span>; <span class="comment">//定义变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tryit: http://tpcg.io/Tulum1</span></span><br></pre></td></tr></table></figure><p>以上代码便是C++最简单可运行的最小示例。基本包含了在程序结构中所必须的一些语言特性。</p><p>根据上述程序结构，我们可以大致将它拆分成五部分内容：</p><a id="more"></a><h2 id="1-include-lt-iostream-gt"><a href="#1-include-lt-iostream-gt" class="headerlink" title="1. #include &lt;iostream&gt;"></a>1. <code>#include &lt;iostream&gt;</code></h2><p>头文件定义主要用于引用第三方函数库，通过调用第三方函数可以减少开发代码量，提高开发效率，同时也避免了不必要的重复造轮子。</p><p>比如：通过引用<code>&lt;cmath&gt;</code>库，可以帮助我们快速使用里面的函数进行一些数学运算。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzmer35re6j30l30j6myt.jpg" alt="函数列表"></p><p>所以，后续我们需要学会便是如何查阅C++文档库，不断积累与完善对于第三方标准库的方法学习与理解。</p><h2 id="2-int-main"><a href="#2-int-main" class="headerlink" title="2. int main()"></a>2. <code>int main()</code></h2><p><code>main</code>函数区别于其它普通函数之处在于: main函数默认被系统定义为应用入口调用方法。除此之外，与其他函数无任何区别。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sayHi</span><span class="params">(<span class="built_in">string</span> username)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"hi, "</span>).append(username).append(<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sayHi(<span class="string">"www.hackdapp.com"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tryit: http://tpcg.io/uHUkzy</span></span><br></pre></td></tr></table></figure><p>函数定义，其实对于所有编程语言的定义方式大致相同, 都可以表现为以下形式</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;返回类型|<span class="keyword">void</span>&gt; 方法名(参数定义<span class="number">1</span>, 参数定义<span class="number">2</span>，参数定义...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do some stuff</span></span><br><span class="line">    <span class="keyword">return</span> &lt;返回数据&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你之前已经在使用其他编程语言，那么应该对于C++其实也可以很好的理解它的程序结构。</p><p>注： 在后续的第二部分，我们会详细介绍函数的多种定义及使用方式，包括形参实参、重载以及虚函数等。</p><h2 id="3-string-message-quot-hi-my-first-app-quot"><a href="#3-string-message-quot-hi-my-first-app-quot" class="headerlink" title="3. string message = &quot;hi, my first app&quot;"></a>3. <code>string message = &quot;hi, my first app&quot;</code></h2><p>变量定义，在程序开发过程，往往需要定义一些临时变量，用于存储在数据逻辑处理过程所必须的临时存储。</p><p>而变量的类型，主要分为字符、整型，长/短整型、单精度、双精度、布尔类型以及字符串。<br>我们在实际应用场景中，需要明确了解与知道这些基础数据类型的定义及边界范围，比如，无符号整型、单精度。</p><p>尤其是对数字类型的字段，如果不了解其边界范围，很可能会导致运算溢出等问题，特别是在合约开发过程中，数字溢出很可能导致的便是相当大的经济损失。</p><p>换个角度讲，合理的使用变量类型，也可能在一定程序中节省资源的浪费。因为在EOS合约中存储数据是需要消耗资源的。</p><p>另外，对于变量的名称定义，其名称只能是由数字、字母以及下划线组成且不可能以数字开头，而且根据不同平台，对于名称的长度其实也是存在限制的。</p><h2 id="4-cout-lt-lt-msg-lt-lt-endl"><a href="#4-cout-lt-lt-msg-lt-lt-endl" class="headerlink" title="4. cout &lt;&lt; msg &lt;&lt;endl"></a>4. <code>cout &lt;&lt; msg &lt;&lt;endl</code></h2><p><code>cout</code>是<code>iostream</code>函数库中的一个流数据输出函数，一般用于在程序调用过程向控制台输入一些调试信息；与此对应的是<code>cin</code>, 用于接收输入数据流。</p><p>不过, 在EOS合约中无法调用此函数。举而代之的是，EOSLIB库自己封装的<code>print</code>函数.</p><h2 id="5-单行注解-or-多行注解"><a href="#5-单行注解-or-多行注解" class="headerlink" title="5. //单行注解 or /*多行注解*/"></a>5. <code>//单行注解 or /*多行注解*/</code></h2><p>在程序开发过程，往往需要通过语言描述某个代码文件所要实现的整体功能或者某个函数的功能、参数及约束说明。这时候就需要用到注解。</p><p>而注解同样也所有的编程语言中也大致相同，一般分为单行注释与多行注释。</p><p>单行注释适用于短小的描述某一行运行逻辑；而多行注释多用于描述函数说明以及文件功能说明。</p><hr><p><code>注：</code> 在教程中如出现不易理解或存在错误的问题🐛，欢迎评论留言！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* filename: myapp.cpp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   date: 2019-01-28 3:06 PM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   auth: zhangliang&amp;lt;zhangliang@cldy.org&amp;gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt; //定义头文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;//命令空间, 简化后续变量或方法调用。e.g. std::string 等同于 string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; msg = &lt;span class=&quot;string&quot;&gt;&quot;hi, my first dapp&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//定义变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; msg &amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//打印字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//tryit: http://tpcg.io/Tulum1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码便是C++最简单可运行的最小示例。基本包含了在程序结构中所必须的一些语言特性。&lt;/p&gt;
&lt;p&gt;根据上述程序结构，我们可以大致将它拆分成五部分内容：&lt;/p&gt;
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="C++导读" scheme="https://www.hackdapp.com/tags/C-%E5%AF%BC%E8%AF%BB/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++导读（EOS完全开发指南）</title>
    <link href="https://www.hackdapp.com/archives/eosdev_cplus_intro.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_cplus_intro.html</id>
    <published>2019-01-28T10:08:35.000Z</published>
    <updated>2021-04-07T09:31:42.555Z</updated>
    
    <content type="html"><![CDATA[<p><code>Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org</code></p><p>本章节内容主要是带大家了解C++整个编程语言的体系架构，对C++编程语言有个整体的大致的认识与理解。另外，也是帮助大家在开发EOS智能合约之前做一下前期预习，易于对后面EOS合约的快速上手。</p><p>另外，需要说明的是，因为本身EOS智能合约是在一个沙箱机制中运行，所以它对一些标准函数库的方法进行了一些限制。所以可能导致大家可能在网上找的资料中的方法无法在合约中正常执行。</p><a id="more"></a><p>另一个角度讲，正是由于这种限制，也是减小了我们的学习范围，这样我们就不需要完全掌握的整个C++的语言体系，便可以开发智能合约。比如：文件操作读取，时间函数，随机数，这些在EOS合约里是都不可用的。 不过，有一个问题就是你无法明确知道哪些功能被禁用了，只能去试。或者官网有说明，可能我没有看到而已。</p><p>在整个开发过程，你只需要学会使用一些基础语法，简单数据类型、数据结构以及常用的一些工具库。比如：如何处理字符串，如何存储或操作数据结构。</p><p>除此之外，再掌握一些程序设计技巧，就可以实战开发自己的DApp应用了，而本身程序设计其实是与哪种程序语言不存在直接关系的，只是让你的程序有更好的应对扩展。</p><p>通过本章节内容你可以学会：</p><ul><li>对基础数据类型以及它们的数据边界有清晰的认识;</li><li>学会如何使用不同数据结构处理业务场景中的问题；</li><li>学会如何定义自己的函数；</li><li>学会如何面对对象的思维设计自己的合约；</li><li>学会如何通过模板封装形成自己的工具库；</li><li>了解一些常用的标准库文件及常用的函数工具方法；</li><li>学会如何通过手册查找工具函数</li></ul><hr><p>本章节，将会从以下八个部分进行分类介绍：</p><p>1.1 C++基础语法<br>1.2 基础数据类型及变量、常量定义<br>1.3 结构体及函数定义<br>1.4 数据结构<br>1.5 面向对象编程<br>1.6 高级应用(模板定义)<br>1.7 标准库及库函数<br>1.8 资源及经验分享</p><hr><p><code>注：</code> 在教程中如出现不易理解或存在错误的问题🐛，欢迎评论留言！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本章节内容主要是带大家了解C++整个编程语言的体系架构，对C++编程语言有个整体的大致的认识与理解。另外，也是帮助大家在开发EOS智能合约之前做一下前期预习，易于对后面EOS合约的快速上手。&lt;/p&gt;
&lt;p&gt;另外，需要说明的是，因为本身EOS智能合约是在一个沙箱机制中运行，所以它对一些标准函数库的方法进行了一些限制。所以可能导致大家可能在网上找的资料中的方法无法在合约中正常执行。&lt;/p&gt;
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="C++导读" scheme="https://www.hackdapp.com/tags/C-%E5%AF%BC%E8%AF%BB/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>坚持的长性</title>
    <link href="https://www.hackdapp.com/archives/think_habit.html"/>
    <id>https://www.hackdapp.com/archives/think_habit.html</id>
    <published>2019-01-21T01:31:24.000Z</published>
    <updated>2021-04-07T09:31:42.554Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzdyksu0ykj30qy0dw400.jpg" alt></p><p>今天早上算是被媳妇嘲笑了一番，为啥呢？</p><p>因为之前自己有一段时间，为了背英语单词，所以早起了一个月，而如今早一天晚一天，早起完全看心情。</p><p>媳妇给出的评价就是：用劲过猛，要么及早要么极迟，完全是一种过激行为。</p><p>同时她也给出建议：只要比上班的时间多出一小时其实就可以做很多事情。重要的是常态化。</p><hr><p>2019开始了，自己确没开始。以前都早早给自己作出各种规划，对比现在，还不如之前的自己吗？不应该是每年比前一年好一些吗或者每天比昨天好一些吗？</p><p>哦，也可能是最近超忙，导致各种规划的推迟。但内心同时又会想起另外一种声音：不，你不是，你只是懒。事情没把你逼到一种绝境上，你是不会立即行动的。</p><h2 id="2019要做的事"><a href="#2019要做的事" class="headerlink" title="2019要做的事"></a>2019要做的事</h2><ol><li>早起，不早起怎么做重要的事；而且希望能找到一些习惯思维方式；</li><li>持续写作，写一本自己的技术书籍，打造自己的硬核；</li><li>持续总结，不犯过去犯的错，少走弯路；</li><li>思考习惯养成路径，以便培养自己新习惯的有效成功率</li></ol><p>注：事情不在多，夯实好这几点。</p><h2 id="目前的状态"><a href="#目前的状态" class="headerlink" title="目前的状态"></a>目前的状态</h2><ul><li>时不时早起起来做一些事情，可能是工作上的，也可能是生活上的，但缺少对书的阅读；另外，感觉早上精力特别出奇的好，是否应该做一些最重要的事情，而读书的化放在晚上的时候。</li><li>未达到持续写东西的地步，需要检讨；可能存在的原因: 对于第二天早上要写的东西，前一天没有大致规划；或者说并不需要规划，每天早上写的时候就按之前的套路写就可以了，不讲究一次写完写完美，而是持续写出自己的每个内容点，草稿结束后再修改，也是告诉自己好文章是持续修改出来的，不可能写完就扔那儿了，而是要持续完善。包括今天写的这篇，其实也是由之前早上写的卡片扩展而来的。</li><li>总结之前过于重视形式化。总结对于我来讲，总感觉认可但又未给予足够的重视，因为总是断断续续的写一些自检清单。可能这个和习惯的养成也是一样，归根到底是没有成长的即视感，也就是没有反馈。比如：刮胡子，为什么要举这个例子呢？因为之前用电动剃须刀时，总是时不时刮一次；而用手动刮胡刀后，发现自己几乎每天都会坚持这件事。当时再想为什么这件事能坚持的如此之前呢？那其他事情怎么不能坚持下去呢？我是否能够从刮胡子这件事情中找到自己内心的那一份认识与感受呢。后来才发现，那是因为刮胡子这件事能让我内心出现一份好形象不邋遢的意识。洗漱的时候就是在潜意识里调动这份动力，而且在刮完胡子后更加让自己内心得以满足，这不正是一种仪式感吗？</li><li>正在有意识，感受自己每天坚持做一件事情的内心是如何的？</li></ul><p>所以，如果要让某个行为成为你的习惯，你就要从内心上提高对它的认可，以及最重要的一件事，你要寻找你的内心感受，是什么让你满足。如果这个不好理解的话，我给你的建议就是观察你已有的习惯中想想那是一种什么感觉，做个比较可能会更形象一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzdyksu0ykj30qy0dw400.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;今天早上算是被媳妇嘲笑了一番，为啥呢？&lt;/p&gt;
&lt;p&gt;因为之前自己有一段时间，为了背英语单词，所
      
    
    </summary>
    
      <category term="思维认知" scheme="https://www.hackdapp.com/categories/%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="习惯养成" scheme="https://www.hackdapp.com/tags/%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90/"/>
    
      <category term="仪式感" scheme="https://www.hackdapp.com/tags/%E4%BB%AA%E5%BC%8F%E6%84%9F/"/>
    
      <category term="内心的满足" scheme="https://www.hackdapp.com/tags/%E5%86%85%E5%BF%83%E7%9A%84%E6%BB%A1%E8%B6%B3/"/>
    
      <category term="2019要做的事" scheme="https://www.hackdapp.com/tags/2019%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>波场Tron-可快捷开发的实战工程模板</title>
    <link href="https://www.hackdapp.com/archives/tron_boilerplate.html"/>
    <id>https://www.hackdapp.com/archives/tron_boilerplate.html</id>
    <published>2019-01-11T22:42:54.000Z</published>
    <updated>2021-04-07T09:31:42.554Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> _                         _           _ _                 _       _</span><br><span class="line">| |_ _ __ ___  _ __       | |__   ___ (_) | ___ _ __ _ __ | | __ _| |_ ___</span><br><span class="line">| __| <span class="string">'__/ _ \| '</span>_ \ _____| <span class="string">'_ \ / _ \| | |/ _ \ '</span>__| <span class="string">'_ \| |/ _` | __/ _ \</span></span><br><span class="line"><span class="string">| |_| | | (_) | | | |_____| |_) | (_) | | |  __/ |  | |_) | | (_| | ||  __/</span></span><br><span class="line"><span class="string"> \__|_|  \___/|_| |_|     |_.__/ \___/|_|_|\___|_|  | .__/|_|\__,_|\__\___|</span></span><br><span class="line"><span class="string">                                                    |_|</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/ChainDesk/tron_boilerplate" target="_blank" rel="noopener"><strong> Tron-Boilerplate</strong></a>, 是基于Tron公链的一套可快速搭建本地私链环境、发布合约以及配置完整的标准工程模板。</p><p>该工程模板旨在于帮助大家快速工程化本地开发环境，减少环境搭建以及调试开发流程过程中所需花费的大量时间，让大家将更多精力投入到产品设计与核心业务逻辑实现上。</p><p>使用提供的工程模板，可从以下四个方面提升开发效率：</p><ul><li>一键启动或暂停私链环境</li><li>一键编译智能合约</li><li>一键发布智能合约</li><li>一键单元测试（jtest）</li></ul><p>同时，本工程模板附带了一个完整的示例代码(<strong>Todolist</strong>)，可供大家参考与学习。示例效果如下：</p><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz354rjq8wg30go09sti8.gif" alt></p><p>最后，开发人员只需按照项目工程结构，编写自己的智能合约、前端页面及与SDK交互逻辑即可。</p><hr><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h3><p><strong> Install Docker for Mac</strong> : <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/</a><br><strong> Install Docker for Windows</strong>: <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a></p><p>更多资料可参考: <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com</a></p><h3 id="2-安装node"><a href="#2-安装node" class="headerlink" title="2. 安装node"></a>2. 安装node</h3><p>To install or update nvm, you can use the install script using cURL:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>or wget<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>The script clones the nvm repository to /.nvm and adds the source line to your profile (/.bash_profile, /.zshrc, /.profile, or /.bashrc)._</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$&#123;XDG_CONFIG_HOME/:-$HOME/.&#125;</span>nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> <span class="comment"># This loads nvm</span></span><br></pre></td></tr></table></figure><p>更多资料可参考: <a href="https://github.com/creationix/nvm#installation" target="_blank" rel="noopener">https://github.com/creationix/nvm#installation</a></p><h3 id="3-安装jdk8"><a href="#3-安装jdk8" class="headerlink" title="3. 安装jdk8"></a>3. 安装jdk8</h3><p>JDK8: <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>如果大家不使用tron提供的tron-studio开发合约的化，可以选择不安装此项。因为使用tronbox同样也可以编译以及发布合约。</p><h3 id="4-安装tronbox"><a href="#4-安装tronbox" class="headerlink" title="4. 安装tronbox"></a>4. 安装tronbox</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g tronbox</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz36n5t5vqj30gk0b1aad.jpg" alt></p><p>注：对于最新的 Java-Tron Odyssey 3.2 版本，最小兼容的 TronBox 版本是 TronBox 2.2.1。请确保您已安装此版本。</p><p>更多资料：<a href="https://cn.developers.tron.network/docs/%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">https://cn.developers.tron.network/docs/%E5%85%A5%E9%97%A8</a></p><h3 id="5-开发工具"><a href="#5-开发工具" class="headerlink" title="5. 开发工具"></a>5. 开发工具</h3><p>开发工具可根据自己喜好自由选择，个人比较推荐<strong>VSCode</strong>。</p><p>官网链接：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><h2 id="工程安装与使用"><a href="#工程安装与使用" class="headerlink" title="工程安装与使用"></a>工程安装与使用</h2><h3 id="1-克隆工程"><a href="#1-克隆工程" class="headerlink" title="1. 克隆工程"></a>1. 克隆工程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:ChainDesk/tron_boilerplate.git</span><br></pre></td></tr></table></figure><p><strong>工程结构介绍</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目地址: https://github.com/ChainDesk/tron_boilerplate</span></span><br><span class="line"><span class="comment"># 注：待工程稳定后，可能会考虑做成插件，可使用yeoman快速构建，欢迎大家star.</span></span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── bin</span><br><span class="line">│   ├── libs</span><br><span class="line">│   │   └── TronStudio.jar//TronStudio开发工具包</span><br><span class="line">│   ├── start_docker.sh//启动私链</span><br><span class="line">│   ├── start_tronstudio.sh//启动TronStudio</span><br><span class="line">│   └── stop_docker.sh//停止私链</span><br><span class="line">├── build//合约编译生成目录</span><br><span class="line">│   └── contracts</span><br><span class="line">│       ├── HelloWorld.json//示例合约ABI, HelloWorld</span><br><span class="line">│       ├── Migrations.json</span><br><span class="line">│       └── TodoList.json           //示例合约ABI, TodoList</span><br><span class="line">├── contracts//合约目录，大家合约都放在这儿</span><br><span class="line">│   ├── HelloWorld.sol</span><br><span class="line">│   ├── Migrations.sol</span><br><span class="line">│   └── TodoList.sol</span><br><span class="line">├── migrations//发布合约目录</span><br><span class="line">│   ├── 1_initial_migration.js</span><br><span class="line">│   └── 2_deploy_contracts.js       //新添加的合约需要在此文件中定义，否则无法通过tronbox deploy命令发布</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json//前端App工程及依赖包定义，以及多个服务启动命令。</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">├── src//前端React代码目录</span><br><span class="line">│   ├── TodoList.js                 </span><br><span class="line">│   ├── contracts</span><br><span class="line">│   │   └── TodoList.json           //合约ABI文件</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── serviceWorker.js</span><br><span class="line">│   └── tronweb.js                  //新启动的工程，需要根据私链生成的私钥以及新发布的合约地址在此重新修改。</span><br><span class="line">├── <span class="built_in">test</span>//jtest测试目录，方便大家编写测试用例</span><br><span class="line">│   └── web.test.js</span><br><span class="line">├── tronbox-config.js</span><br><span class="line">└── tronbox.js//发布合约所依赖的配置，此文件定义了本地、测试以及正式网络的http访问地址</span><br><span class="line"></span><br><span class="line">12 directories, 27 files</span><br></pre></td></tr></table></figure></p><h3 id="2-工程初始化"><a href="#2-工程初始化" class="headerlink" title="2. 工程初始化"></a>2. 工程初始化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这一步主要用于更新前端框架react所依赖的包文件，依赖包安装成功后，会在工程目录下看到一个<code>node_modules</code>文件夹。</p><p>如果你的前端选型不是react的化，也可根据自己需求进行依赖包配置修改。</p><h3 id="3-正式开发流程"><a href="#3-正式开发流程" class="headerlink" title="3. 正式开发流程"></a>3. 正式开发流程</h3><h4 id="3-1-启动链环境"><a href="#3-1-启动链环境" class="headerlink" title="3.1 启动链环境"></a>3.1 启动链环境</h4><p>执行<code>cmd+shift+p</code>，调用vscode的命令列表，选择run task从中选择start_docker任务_</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz37ttdzdsg30go09sn7r.gif" alt><br>同样，如果要停止当前docker环境，只需选择stop_docker脚本即可。_</p><p>所有的执行任务配置默认只存在两个地方:</p><ul><li>tron_boilerplate/.vscode/tasks.json_</li><li>package.json中的scripts<br>大家可根据自己需要进行添加或修改，而且也可以通过IDE本身的快捷键映射对应的任务。</li></ul><h4 id="3-2-发布合约"><a href="#3-2-发布合约" class="headerlink" title="3.2 发布合约"></a>3.2 发布合约</h4><p>运行task任务，然后从中选择<code>npm deploy</code>, 即可发布当前所有合约至私链环境。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz380y3oeog30go0907wh.gif" alt></p><p>合约发布成功后，会显示如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Using network <span class="string">'development'</span>.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Replacing Migrations...</span><br><span class="line">  Migrations:</span><br><span class="line">    (base58) TBC7CqpjBxGUt9Z9hhM4QNRFF5osvG3j6r</span><br><span class="line">    (hex) 410d68b1bfd19d341bd0f772fad8697432d0d771be</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Replacing TodoList...</span><br><span class="line">  TodoList:</span><br><span class="line">    (base58) TFyEw5qRRiZTJ5boLZJxZnv2hnhpBuvkjm</span><br><span class="line">    (hex) 4141d25df475fe0c053a9e2ed3a77faa10329185f0</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><h4 id="3-3-修改配置参数"><a href="#3-3-修改配置参数" class="headerlink" title="3.3 修改配置参数"></a>3.3 修改配置参数</h4><p>打开文件, tron_boilerplate/src/tronweb.js, 代码如下: _<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const fullNode = new HttpProvider(<span class="string">'http://127.0.0.1:8090'</span>);</span><br><span class="line">const solidityNode = new HttpProvider(<span class="string">'http://127.0.0.1:8091'</span>);</span><br><span class="line">const eventServer = <span class="string">'http://127.0.0.1:8092'</span>;</span><br><span class="line"></span><br><span class="line">const privateKey = <span class="string">"&lt;私钥地址&gt;"</span>;</span><br><span class="line">const contractAddr = <span class="string">"&lt;合约地址&gt;"</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><h4 id="3-4-启动react服务"><a href="#3-4-启动react服务" class="headerlink" title="3.4 启动react服务"></a>3.4 启动react服务</h4><p>执行<code>cmd+shift+p</code>，调用vscode的命令列表，选择run task从中选择<code>npm start</code>即可启动前端服务。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz3883zfdlg30go091txz.gif" alt></p><p>打开浏览器，访问<a href="http://localhost:3000，" target="_blank" rel="noopener">http://localhost:3000，</a> 验证是否成功。</p><hr><p>到此，整个工程的搭建及开发流程就介绍完毕，如中间出现任何问题欢迎加我个人微信咨询。</p><h2 id="开发资料"><a href="#开发资料" class="headerlink" title="开发资料"></a>开发资料</h2><ul><li>波场官网：<a href="https://tron.network/index?lng=zh" target="_blank" rel="noopener">https://tron.network/index?lng=zh</a></li><li>波场区块链浏览器（主网）： <a href="https://tronscan.org/#/" target="_blank" rel="noopener">https://tronscan.org/#/</a></li><li>波场区块链浏览器 （测试网）<a href="https://test.tronscan.org/#/" target="_blank" rel="noopener">https://test.tronscan.org/#/</a></li><li>Documentation: <a href="https://github.com/tronprotocol/Documentation" target="_blank" rel="noopener">https://github.com/tronprotocol/Documentation</a></li><li>TRON开发者文档: <a href="https://developers.tron.network/" target="_blank" rel="noopener">https://developers.tron.network/</a></li><li>开发工具介绍: <a href="https://medium.com/tron-foundation/an-all-in-one-tool-suite-for-tron-developers-d048b2bc9b6c" target="_blank" rel="noopener">https://medium.com/tron-foundation/an-all-in-one-tool-suite-for-tron-developers-d048b2bc9b6c</a></li><li>TRON Chrome插件集成示例：<a href="https://github.com/tronpay/TronPay-Extension" target="_blank" rel="noopener">https://github.com/tronpay/TronPay-Extension</a></li><li>Tron-BIP44 implementation： <a href="https://www.npmjs.com/package/@faast/tron-payments" target="_blank" rel="noopener">https://www.npmjs.com/package/@faast/tron-payments</a></li><li>TRON开发项目模板(tron_boilerplate)：<a href="https://github.com/ChainDesk/tron_boilerplate" target="_blank" rel="noopener">https://github.com/ChainDesk/tron_boilerplate</a></li></ul><hr><blockquote><p>在教程中如出现不易理解或存在错误的问题，欢迎加我微信指正！<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      本教程通过以自己定制的工程模板为示例，讲解工程构建、快捷键部署私链及整体完整的开发注程，并配以操作动图帮助大家理解。hackdapp愿与你分享。 HackDApp愿与你分享！
    
    </summary>
    
      <category term="区块链技术" scheme="https://www.hackdapp.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tron boilerplate" scheme="https://www.hackdapp.com/tags/tron-boilerplate/"/>
    
      <category term="波场开发指南" scheme="https://www.hackdapp.com/tags/%E6%B3%A2%E5%9C%BA%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>2019MetaLife</title>
    <link href="https://www.hackdapp.com/archives/2019metalife.html"/>
    <id>https://www.hackdapp.com/archives/2019metalife.html</id>
    <published>2019-01-07T16:28:42.000Z</published>
    <updated>2021-04-07T09:31:42.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong>新年愿意清单</strong></p><ul><li>尝试每天500字，锻炼文字组织能力</li><li>做一款自己的小众产品，用户达到100人</li><li>尝试录制短视频</li><li>出版一本书籍</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;新年愿意清单&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试每天500字，锻炼文字组织能力&lt;/li&gt;
&lt;li&gt;做一款自己的小众产品，用户达到100人&lt;/li&gt;
&lt;li&gt;尝试录制短视频&lt;/li&gt;
&lt;li&gt;出版一本书籍&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="新年计划(2019)" scheme="https://www.hackdapp.com/categories/%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92-2019/"/>
    
    
  </entry>
  
</feed>
